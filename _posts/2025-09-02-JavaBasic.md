---
title: "Java基础"
date: 2025-09-02 21:00:00 +0800
categories: [Java]
tags: [Java]
---
本文档暂时只提供对Lancet代码的补充说明，后续将扩充Java基础语法，工程结构等。

## 元注解
Java中的元注解是用来修饰注解的注解，常见的有以下几种：

| 元注解       | 作用               | 说明         |
|--------------|-------------------------------|-------------------------------------------|
| `@Retention` | 指定注解的生命周期| 如 `SOURCE`、`CLASS`、`RUNTIME`                              |
| `@Target`    | 指定注解可以应用的Java元素类型 | 如 `TYPE`（类、接口）、`METHOD`（方法）、`FIELD`（字段）等   |
| `@Documented`| 指示注解是否包含在Javadoc中    | 如果使用该注解，注解信息会被Javadoc工具提取出来，默认不包含   |
| `@Inherited` | 指示注解是否可以被子类继承  | 只对类注解有效，子类会自动继承父类的注解   |

## InsertClassVisitor 工作机制
负责将Hook方法织入到目标类的指定方法。
### 主要流程
1. 类级别处理
- 当 ASM 访问到一个类时，visit 方法会被调用。
- 通过 executeInfos.get(getContext().name) 获取当前类所有需要插入的 InsertInfo（即所有与该类相关的 hook 规则）。
- 这些 InsertInfo 会在后续方法遍历时用到。

2. 方法级别处理
- 遍历类的每个方法，查找与 InsertInfo 匹配的方法（方法名和方法签名一致）。
- 校验 static 修饰符是否一致（hook 方法和目标方法必须同为 static 或非 static）。

- 如果找到匹配项且方法不是 native/abstract：
    - 生成一个“孪生”方法（newName = name + "$twin"，私有），保存原始方法逻辑。
        - 构建 MethodChain，将所有 hook 方法链式织入到目标方法。
            - chain.headFromInsert：记录孪生方法的头部信息。
            - chain.next：将每个 hook 方法按顺序加入链条。
            - chain.fakePreMethod：生成一个“假方法”，用于后续织入。
    - 最终用 super.visitMethod 新增孪生方法，原方法将被 hook 逻辑替换。

3. 生成 super 调用（visitEnd 方法）
- 有些 hook 规则要求在插入逻辑中能访问父类的原始方法（createSuper 标记）。
- visitEnd 会自动为这些方法生成一个方法体，调用 super.method 并返回结果，- 保证 hook 后仍可访问原始父类逻辑。

## JSON
JSON（JavaScript Object Notation）是一种轻量级的数据交换格式, 广泛用于前后端数据传输。  


### json解析过程
JSON解析指的是将JSON格式的字符串转换成程序中可以操作的数据结构（如对象、数组等）的过程。

1. 词法分析 (Lexical Analysis / Tokenization)
把输入的JSON字符串分解成一系列的“记号”(Token)，如括号 {、}、方括号 [、]、逗号 ,、冒号 :，以及字符串、数字、布尔值、null等字面量。

``` json
{
  "name": "Alice",
  "age": 25
}
```

分解成的Token序列

``` json
{, "name", :, "Alice", ,, "age", :, 25, }
```

2. 语法分析 (Parsing)
根据JSON的语法规则，构建一个抽象语法树（AST）或直接构造对应的数据结构。过程为:
- 识别对象（用 {} 包围）和数组（用 [] 包围）。
- 解析键值对，字符串，数字，布尔值，null等。
- 递归处理嵌套结构。

``` json
Object
 ├─ Key: "name", Value: "Alice" (string)
 └─ Key: "age", Value: 25 (number)
```

3. 语义检查(Semantic Analysis)
确保数据符合JSON规范,包括键必须是字符串; 值必须是有效的JSON类型（字符串、数字、对象、数组、布尔值、null）。

4. 数据结构构建
- 将解析结果转换成程序语言中的数据结构：
    - 在 JavaScript 中，转换成对象（Object）和数组（Array）。
    - 在 C 语言中，可能转换成结构体、链表等。
    - 在 Python 中，转换成字典（dict）和列表（list）。
- 解析器会分配内存，存储对应的键值对和数组元素。

5. 解析完成
- 返回解析后的数据结构，供程序使用。
- 如果解析过程中发现错误（如格式错误、缺少逗号、引号不匹配等），则会返回错误信息。

## 垃圾回收机制(Garbage Collection, GC)
Java 是一种带有自动内存管理的语言，垃圾回收机制负责自动释放不再使用的对象所占用的内存，避免程序出现内存泄漏和内存溢出。

垃圾回收主要发生在 堆内存 中。Java 堆是**所有对象实例**的存储区域。

堆内存一般划分为几个区域：
- 新生代（Young Generation）：存放新创建的对象
- 老年代（Old Generation）：存活时间较长的对象会被移到这里
- 永久代/元空间（PermGen/Metaspace）：存放类的元数据

### 基本原理
GC 的核心是判定哪些对象是“垃圾”，即不再被任何活动的线程或变量引用。

主要判定方法：
- 引用计数法：给对象维护一个引用计数，计数为0时回收（**Java 不采用此法**，因为循环引用问题）。
- 可达性分析算法（Reachability Analysis）：从一组称为“GC Roots”的对象开始，沿引用链搜索所有可达对象，未被可达的对象视为垃圾。

### 垃圾回收算法
1. 标记-清除
- 标记阶段：标记所有需要回收的对象。
- 清除阶段：清除被标记的对象，释放内存。

缺点：会产生大量不连续的内存碎片。

2. 复制算法
- 将内存分为两块，每次只使用一块，另一块为空闲。
- 把存活对象复制到空闲区，清理掉原来区域所有对象。

优点：没有内存碎片，适合新生代。

3. 标记-整理
- 标记阶段同标记-清除。
- 整理阶段，把存活对象向一端移动，清理端边界以外的内存。

避免了碎片问题，但移动对象需要额外开销。

## 引用(Reference)
Java 中的引用, 本质上是一个指向对象的“句柄”或“指针”的抽象，但它不是一个内存地址的变量，而是由 JVM 管理的一种对对象的间接访问方式。
- 它指向堆上的一个对象实例。
- 通过引用来访问对象的属性和方法。
- 引用本身不能做算术运算，也不能直接操作内存。
- 引用可以是 null，表示不指向任何对象。

- 引用变量存储的是对象的引用信息，但这个信息对程序员是透明的，程序员看不到具体的内存地址。
- Java 通过引用来实现“传递对象”的机制（传递引用的副本）。
- **引用是对象的别名**，引用本身不可变（不能指向其他对象），但对象内容是可变的。

| 特性             | Java引用                     | C++指针                      |
|------------------|------------------------------|------------------------------|
| 是否直接存储内存地址 | 否，JVM管理引用的具体实现          | 是，变量存储实际内存地址           |
| 是否支持指针运算   | 否                            | 是                            |
| 是否可以修改指向   | 否，引用一旦指向某对象不可变         | 是，可以改变指针指向             |
| 是否需要手动管理内存 | 否，JVM自动垃圾回收               | 是，程序员需手动管理内存          |
| 是否能为null       | 可以                         | 可以                         |