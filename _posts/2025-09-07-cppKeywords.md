---
title: "C++ 关键字"
date: 2025-09-07 11:30:00 +0800
categories: [C++]
tags: [C++, Keywords]
---

关键字是具有特殊意义的预先定义保留识别项。  

## const
const关键字用于声明变量为"常量"，即该变量的值在初始化后不可更改。
不仅适用于基本数据类型，也适用于指针、引用、类成员等多种场景。

### 1. 修饰变量
``` C++
const int MAX_SIZE = 100；
```
### 2. const指针
#### 指向常量的指针(pointer to Const)(*在后)
	- 指针指向的数据不能通过这个指针修改
	- 可以改变常量指针指向其他地址
``` cpp
const int* ptr; 
// 或者 int const* ptr; (别记这个，牢记*跟着int走)
```
#### 指针常量(Const pointer)(*在前)
又叫常指针，指针本身是常量，即指针的地址不能被修改，但可以通过它来修改地址里内容

``` cpp
int a = 5;
int b = 10;
int * const ptr = &a;
*ptr = 20; // 合法。 可以修改指向的数据
// ptr=&b; //不合法，指针常量的地址不能改变
```
#### 指向常量的常量指针
指针本身(地址)和指向的内容都不能修改
> 注意，这里的概念极其混淆，pointer to const有时候也叫常量指针，用于和指针常量区分，但是const pointer本身翻译就是"常量指针"，所以指针常量在某些文章中被称为"常量指针"。
> 综上，以英文为准。

### const引用()
reference to const `(const T& ref)` 和 const reference `(const T& ref)` 等价
引用不允许改变引用本身（引用一旦绑定，不能再指向别的对象），所以reference本身是“常量”的。

### 3. const函数应用
#### 3.1 作为参数
- 3.1.1 传值参数中的const
	- const修饰传值参数 对调用者没有影响，因为传值参数在函数内部就是副本，仅仅是防止在函数内部修改变量
- 3.1.2 传引用
	对引用或指针参数使用const，防止函数修改调用者的数据
#### 3.2 返回类型
- 函数返回类型可以被声明为const。对于按值返回的函数没意义，因为传回的是副本。
- 如果返回是引用或指针类型的，可能会导致篡改类内数据。使用const45人 修饰按引用或按指针传递的返回类型，可以避免修改原始数据。

### 4. const类内使用
#### 4.1 const成员函数
##### 特点  
1. **不修改对象的状态**：函数在执行过程中不会修改对象的任何成员变量(除非成员变量被声明为可变)
2. **只能调用其他常成员函数**：在这个成员函数内部，只能调用其他被声明为const的成员函数
，确保不会通过间接调用修改对象状态。
3. 可以通过[常量对象]或[pointer/reference to const]调用这个成员函数。
4. 非const对象也可以调用const成员函数
5. 基类和派生类中, const修饰必须一致，以确保多态性和正确性
6. 临时对象默认是const, 只能调用const成员函数

#### 4.2 const对象
在对象的声明前使用const关键字
在声明时被指定为const的对象。意味着对象一旦被创建，其状态(成员变量的值)不能被修改。  
对于类的对象，可以同样使用const
``` C++
class Point{
public:
	int x_, y_;
	Point(int x, int y): x_(x), y_(y){}
	void move(int dx, int dy){
		x_ += dx;
        y_ += dy;
	}
	int getx() const {return x_}; //这里const表示该成员函数不会修改对象的成员变量
	int gety() const {return y_};
};

//实例化对象
const Point p(1,2);
cout << p.getx() << endl;
```

- 特点：
	- 不可修改
	- 只能调用const 成员函数
#### 4.3 const成员变量
类的成员变量可以声明为const, 需要在初始化列表中进行初始化，且不可更改。  
初始化列表就是指构造函数中根据传入值初始化。

### 5. const与类型转换
- **`const_cast`**
用于移除或添加对象的const属性，主要用于指针和引用  
滥用const_cast可能导致未定义行为
- **`static_cast`**
不会修改const属性
	
### 6. const变量和宏变量有什么区别
- **类型安全**
  - `const` 变量有明确类型，编译器会进行类型检查，确保类型安全。
  - 宏只是简单的文本替换，没有类型信息。

- **作用域**
  - `const` 遵循 C++ 作用域规则，可以定义在局部或全局范围，具有明确作用域。
  - 宏在定义后，直到文件结束或被 `#undef`，在整个预处理范围内有效，可能导致命名冲突。

- **编译器处理**
  - `const` 由编译器处理，具有类型信息和作用域，能进行优化，如内联替换。
  - 宏变量由预处理器处理，仅文本替换，不参与编译器的类型检查和优化。
  - 仅文本替换，不参与运算：请注意文本替换后的运算顺序问题。

- **调试**
  - 调试时 `const` 变量有明确的地址和值。
  - 宏在预处理后被替换，没有独立的实体。

### const 位置和含义
1. const成员函数 放在**函数声明后面**
``` cpp
int getValue() const;
```
- `const`是修饰成员函数本身，告诉编译器该函数不会修改类的成员变量（除非成员变量是`mutable`

2. 放在函数类型前面

``` cpp
const int getValue();
const int& getConstRef() const;
```
- `const`修饰返回值，表示返回的是一个常量值，调用者不能修改返回的值（对内置类型如int无太大意义，但对返回引用或指针时很重要）。

3. 放在函数参数前面，修饰参数类型

``` cpp
void setName(const std::string& name);
```
- 表示函数参数是不可修改的引用，防止函数体内修改传入的参数。

4. 放在指针类型前后，修饰指针或指针指向的内容

``` cpp
const int* p1;  // 常量指针，不能通过p1修改所指内容
int* const p2;  // 指针常量，指针本身不可修改，但指向内容可改
const int* const p3; // 指向常量的常指针，指针和内容都不可改
```

## constexpr
constexpr是const exprssion的缩写，用于指示编译器某个值或表达式可以在编译期间求值。  
编译时就能确定值，可以提高程序运行效率，允许更多编译期优化。
### constexpr变量
constexpr变量必须在定义时初始化，并且初始化表达式必须在编译时可求值。
### constexpr函数
在编译时可求值的函数，用constexpr修饰返回值
c++11版本，函数体内仅包含一条return 语句。
c++14版本后可以包含多条语句，如条件判断、变量声明等。 
### constexpr与类
#### constexpr构造函数
被constexpr修饰的构造函数，其所有成员必须是字面类型
> [字面类型]:可以在编译时计算的类型，比如int, double
> 字面类型包括：标量类型、引用类型、数组类型、满足条件的类或结构体
当声明一个对象为constexpr时，整个对象及其成员的初始化在编译时完成。
在constexpr构造函数中，只能执行那些在编译时求值的操作。
#### constexpr成员函数
函数必须声明为constexpr
函数体内所有操作必须在编译时可求值
#### constexpr静态成员变量
必须在类内声明为static constexpr
		
### constexpr的规则和限制
1. 必须在定义时初始化
2. 初始化表达式必须是编译时常量
3. constexpr构造函数类的成员变量必须在编译时初始化，不允许有虚函数或虚继承。因为编译器无法确定具体调用哪个虚函数实现。
4. 类型限制：只有字面类型才能用constexpr修饰
	
## extern
用于声明变量或函数在其他文件中定义。  
主要用于实现[跨文件的变量和函数共享]，帮助编译器了解变量或函数的存在，而不必在当前文件重复定义。

### 声明外部变量
一个变量在一个文件中定义后，如果需要在其他文件中使用该变量，就需要使用`extern`关键字声明。  
可以用于声明类的外部对象，注意是**对象**，步骤：  
1. 在一个源文件中(如main.cpp)定义类的对象
2. 在一个头文件中使用 `extern` 声明该对象
3. 在其他需要使用该对象的源文件中包含该头文件，从而访问同一对象

### 声明外部函数
函数在一个文件中定义后，可以在其他文件中使用，无需再次定义，但可以通过函数原型进行声明。
这里说的外部函数通常是全局函数，即具有全局链接。  
使用static关键字声明的全局变量具有内部链接，仅在定义它的源文件可见，所以这类函数不适用于`extern`
### 链接规范 `extern "C"`
用于指定使用C语言的编译方式。常用于c和c++的混合编程，避免名称修饰导致的链接错误。  
c++支持函数重载，相同的函数名称可以传入不同参数列表，通过[名称修饰]实现
然而c不支持函数重载，所以为了在c++中调用C或让C调用c++函数，使用extern "C" 避免名称修饰.

> [名称修饰]：是编译器在编译过程中对函数名、变量名等进行的一种转换。
> 转换的目的是为了支持某些语言特性，比如函数重载、类成员函数等。
> 名称修饰使得编译器在生成的目标代码中唯一地标识每个函数和变量，即使他们在源代码中有相同名字。
- 作用: 告诉c++编译器，将指定函数用C规则编译(不用名称修饰)
- 用法：在函数声明上面加一个extern "C",由于是函数申明所以一般放在头文件里。
### 注意事项
1. 避免多重歧义：
使用extern可以防止多个文件中重复定义同一个变量或函数，但需要确保每个全局变量或函数在整个程序中只有一个定义。
2. 初始化外部变量
extern声明的变量不能初始化。初始化只能在变量定义时进行。
``` C++
extern int gVar =10; //这会编译错误。
```
3. 若在多个文件中使用extern声明但没有提供相应定义，会导致链接错误。
4. 局部变量
extern关键字用于声明全局变量或函数，不能用于局部变量。
5. 命名空间影响
C++中，`extern`声明也受限于命名空间。
			
## static
`static` 关键字用于控制变量和函数的生命周期、作用域及访问权限，涵盖全局变量、局部变量、函数以及类成员。
### 1. 静态变量  
- 1.1 静态全局变量  
	- 在函数外部(文件作用域)中定义。
	- 静态存储期，在程序整个生命周期中存在
	- 具有**内部链接性**，即该变量只在定义它的源文件中访问，无法被其他源文件使用，有助于实现封装，防止命名冲突。  
- 1.2 静态局部变量  
	- 在函数或代码块内部使用。  
	- 静态存储期，变量在程序运行期间只初始化一次，多次函数调用期间保持其值。
	- 作用域仅限于定义它的函数内部。 

### 2. 静态函数 
static关键字作用于函数, 分为全局静态函数和类的静态成员函数
- 2.1 全局静态函数
	- 内部链接，只能在定义他的源文件中调用，不能被其他源文件访问

### 3. 类的静态成员
- 3.1 静态成员变量
	- 静态成员变量属于整个类。所有类的实例共享同一个静态成员变量。
	- 静态成员变量必须在**类外定义**，以分配存储空间。
	- 这里定义一般放在类定义(如A.cc)所在的文件里。注意不能在main()里初始化,main也是函数有局部作用域
	- 由于静态成员变量与类的所有实例共享，因此必须在一个确定的翻译单元中进行定义，以避免链接时出现重复定义或未定义错误。
	- 可以不显式初始化，编译器会分配默认值：内置类型如(int, char)置零，类类型调用对应默认构造函数
	- 常态静态成员变量(且是整型)可以在类定义内初始化。

- 3.2 静态成员函数
	- 类中静态函数属于整个类，而不是某个特定对象。
	- 可以在没有类实例的情况下被调用，通过`类名::函数名`
	- 静态成员函数只能访问静态成员变量和其他静态成员函数，不能访问类的非静态成员。

### 4. 静态存储期
> **静态存储期**指变量在程序的整个生命周期存在。
使用`static`关键字声明的变量,无论作用域如何(全局、静态变量、类的静态成员)，都具有静态存储期。
- 变量在程序开始时分配内存，在程序结束时释放内存。

### 5. 存储位置
- 静态变量（包括静态局部变量和静态成员变量）和全局变量都在数据段（data segment），而非栈区。

- Q:静态成员变量何时被分配到内存的数据段？
- A:在程序加载(编译->链接->加载)时被分配到内存的数据段
	- 全局静态成员变量在程序启动时被初始化, 并在整个程序运行期间存在。
	- 局部静态成员变量在程序第一次执行到定义所在代码时被初始化, 并在整个程序运行期间存在。

	具体来说：  	
	- 在编译阶段：编译器识别类中的静态成员变量，并为其分配内存地址。由于静态成员变量通常定义在对应.cpp文件中，编译器在该文件的符号表中为其分配一个全局符号
	- 在链接阶段：链接器将所有翻译单元中的符号解析并分配到最终可执行文件中
	- 在程序加载阶段：将可执行文件加载到内存中，分配数据段的空间存储静态成员变量

### 5. 其他用法
- **匿名命名空间**
就是不带名字的namespace, 可以取代全局静态变量和全局静态函数的使用，有更好的灵活性和可读性

### 6. 继承问题
- 静态成员变量属于类本身，可以被派生类继承，但只有一份存储空间
- 静态局部变量只在定义它的函数作用域内有效，不是类成员，不存在继承问题。
- 静态成员函数可以被继承，在访问权限允许情况下可以被调用。

### 7. 静态方法不能是虚方法
	静态方法(静态成员函数)不依赖于对象实例，而虚方法需要通过对象实例调用。通过基类指针或引用调用虚方法时，会根据实际对象类型执行相应的重写方法。
		
### 8. c++11新特性
C++11在语言标准中明确规定，局部静态变量的初始化是线程安全的。这意味着：
1. 单次初始化：	无论多少线程同时调用包含局部静态变量初始化的函数，变量只会初始化一次。
2. 同步机制：	编译器会自动处理必要的同步，确保变量完全初始化之前，其他线程无法访问该变量
3. 无数据竞争：	消除因多线程竞争导致的初始化数据竞争问题。

## noexcept
c++11引入，所修饰的函数在执行过程中不会抛出异常。这意味着catch不会捕获到异常
### 常见用途
标记移动构造函数和移动赋值运算符为 `noexcept`，以便容器等标准库组件能够进行更高效的操作。

## virtual
用于声明虚函数的关键字。
- 虚函数允许在继承层级结构中实现动态绑定，即在运行时根据对象的实际类型调用相应的函数，而不是根据指针或引用的静态类型。
- 虚析构函数
	- 当使用基类指针删除子类对象时，如果基类的析构函数不是虚函数，可能导致资源泄漏。
	- 确保正确调用子类的析构函数
	- 资源泄漏的原因：如果基类的析构函数不是虚函数，会调用基类的析构函数。

- 虚函数表
	虚函数表是用来支持运行时多态的机制。当一个类声明了虚函数时，编译器为该类生成一个虚函数表。这个表包含指向该类所有虚函数的指针。
- 虚表指针
	每个对象中有一个指向虚函数表的指针，称为虚表指针

- 实现原理：
	- 虚表(vtable)是一个静态表格，存储了指向类的虚函数的指针。
    - 如果派生类重写了虚函数，编译器会为派生类生成一张新的虚函数表，覆盖对应虚函数指针。
	- 虚表指针(vptr)：每个对象包含一个隐藏的指针，指向该对象所属类的虚表。
		vptr通常在对象的内存布局中位于最前面。
- 工作机制：
	- 当对象被创建时，**构造函数**负责初始化vptr,让它指向所属类的虚表。
		- 对于继承关系，子类的构造函数会覆盖父类的vptr，指向子类的虚表。
	- 当通过基类指针或引用调用虚函数时，编译器生成代码，通过对象的vptr访问虚表，从虚表中找到相应的函数指针，并调用该函数
- 实现细节:
	- 虚表通常保存在只读数据段中，防止被意外修改。
	- 每个对象的内存布局中自动插入一个vptr，指向类的虚表。
	- 当子类重写虚函数时，子类的虚表会包含指向子类实现的函数指针，覆盖父类的相关条目。

- 单继承情况下，派生类的虚表覆盖（override）基类的虚函数表项，派生类虚表是独立的，指向派生类自己的虚函数实现。
- 多继承情况下，当一个类从多个基类继承（多继承）时，每个基类子对象部分有自己的虚表指针（vptr），因此，派生类对象中会有多个虚表指针，每个对应一个基类子对象。

- 为什么构造函数不能是虚函数？
构造函数是用于对象初始化的，而虚函数依赖于虚函数表，虚函数表的建立是在对象构造过程中设置的。

## inline(内联)
内联是一种将函数或变量的实际代码嵌入到调用点的优化方法。
- 优点
	1. 消除函数调用的开销：避免执行跳转指令和堆栈操作
	2. 优化代码：允许编译器在内联后对代码进一步优化，如常量折叠
	3. 提高缓存性能：减少函数调用带来的指令跳转，有助于提高指令缓存的命中率
- 缺点：
	1. 代码膨胀：增加可执行文件的大小
	2. 编译器需要处理更多的代码替换，可能增加编译时间
- inline作用
	1. 建议编译器将函数内联,编译器根据自身优化策略决定是否内联
	2. 

- 完全内联：
	编译器将函数或变量的所有访问点都进行内联处理，确保生成的机器代码中不再存在任何间接访问或函数调用的痕迹

- 引用中的完全内联
	将引用转为对原始变量的直接操作，避免生成实际的指针操作
	
- c++17开始，可以使用inline在类内部进行静态成员变量初始化
	static inline A* instance = nullptr;

## friend
授予某个类或函数对另一个类的private和protected成员的访问权限

## decltype 
是 C++11 引入的一个关键字，用于查询表达式的类型
	define、typedef、inline
		define
			只是简单的字符串替换，没有类型检查
			在编译的预处理阶段起作用
			防止头文件重复引用
			不分配内存
		typedef
			用于创建类型的别名，提高代码的可读性和可维护性。
			有对应数据类型, 在编译时检查
			在编译、运行时起作用
		inline
			将内联函数编译完成后插入被调用的地方
			减少压栈、跳转和返回操作，减少函数调用开销
			是一类特殊函数，会进行类型检查
			编译器有可能拒绝inline请求
	
	const和define区别
		const定义常量，define定义宏
		const生效于编译阶段，define生效于预处理阶段
		const定义的常量存储在内存中，define不分配内存
		const定义常量有类型，define不带类型
		
	new 和 malloc
		new是c++运算符, malloc属于c标准库函数
		new分配内存并调用构造函数， malloc仅分配内存
		new 返回特定类型指针，malloc返回void*，需要显式类型转换
		new 分配失败时抛出std::bad_alloc异常, malloc返回NULL
		new 使用delete或delete[]释放内存，并自动调用析构函数, malloc使用free
		
			
const 和constexpr
	const用于声明一个变量为只读，即值在初始化后不能修改
	constexpr声明在编译时可以求值的常量表达式，在 需要编译时常量或优化 时使用
			
volatile
	与const绝对对立
	作用：确保本条指令不会因编译器优化而省略，保证对特殊地址的稳定访问

## override
C++11以后新增的一个标识符，用来显式标记这是一个重写基类虚函数的函数。  
编译器会检查：  
- 派生类的函数是否确实重写了基类的虚函数。
- 如果没有（比如基类函数不是虚函数，或者函数签名不匹配），编译器会报错。

换句话说：
> override只能用于重写基类的虚函数。