---
title: "操作系统"
date: 2025-08-25 17:00:00 +0800
categories: [操作系统]
tags: [标签1, 标签2]
---

## 1. 文件描述符
文件描述符是一个非负整数，用于标识进程中打开的文件或其他I/O资源。  
文件描述符充当进程和内核之间的桥梁，使进程能通过文件描述符对各种I/O资源进行操作。
    
- 工作原理：
    1. 当进程打开一个文件或其他I/O资源时，内核分配一个文件描述符，并在进程文件描述符表中记录相关信息。
    2. 进程通过文件描述符执行读取、写入、关闭等操作，内核根据文件描述符从全局文件表中找到对应资源
    3. 进程不再需要访问某个资源时，通过关闭文件描述符释放相关资源。
		

## 2. 内存管理
C程序的内存分为以下几个区域：
- 栈：存储局部变量和函数调用信息，自动管理
- 堆：用于动态内存分配，程序员手动管理
- 数据区： 存储全局变量和静态变量
- 代码区： 存储程序的可执行代码  
    
C语言通过标准库函数在堆上动态分配和释放内存
- malloc: 分配指定字节数的内存，返回指向该内存的指针
- calloc: 分配指定数量的元素，每个元素大小，并将内存初始化为0
- realloc:调整之前分配的内存块的大小
- free:	释放之前分配的内存

## 3. 内存管理(RAM)
RAM和ROM和缓存：  
- RAM中数据在电源断电时会丢失
- ROM中数据在制造时被永久写入，通常用于存储固件。
- Cache(缓存):位于CPU和RAM之间的高速存储器，用于临时存储频繁访问的数据，以缩短数据访问时间。

操作系统引入虚拟内存，通过内存管理单元(MMU Memory Management Unit)将虚拟内存映射到物理内存。

### 分段和分页
操作系统通过**分段和分页**管理虚拟地址和物理地址的关系？
#### 分段
- 分段机制下的虚拟地址由两部分构成：[段选择因子]和[段内偏移量]
- 段选择因子包含段号，作为段表的索引。
- 而段表里面包含段的基地址、段的界限和特权等级等。
- 如果段内偏移量合法，段的基地址+偏移量就是物理内存地址。
    
分段机制会把虚拟地址分为4个段：栈、堆、数据、代码  
每个段在段表中都有一个项。

#### 分段的问题
1. 内存碎片
2. 内存交换的效率低
		
#### 内存碎片
内存碎片分为内部内存碎片和外部内存碎片。
##### 内部内存碎片
内部内存碎片指：分配给进程的内存块大于实际使用需求。
根据实际需求分配内存，可以避免内部内存碎片。

##### 外部内存碎片
内存中出现由于动态分配和释放导致内存中出现很多小的、不可利用的小内存片段。

- 解决外部内存碎片的方法  
可以把部分占用进程占用的内存写到硬盘上，再从硬盘读回内存，并装载在已使用内存的相邻位置。  
Linux中常用的swap空间，就是从硬盘中划分出来，专门用于内存和硬盘交换的空间。
- swap问题  
swap涉及与硬盘的交互，效率很低。

#### 分页
分页的目的是改进分段产生内存碎片的问题。

分页把整个虚拟和物理内存空间切成一段段固定尺寸的大小。页的大小为4KB。
	
#### 页表和MMU
虚拟地址和物理地址通过页表来映射。  
页表是一种数据结构，维护虚拟内存和物理内存之间的映射关系。  

MMU是硬件组件，负责执行实际的地址转换和访问控制。

- 缺页异常：
    当进程访问的虚拟地址在页表中查不到时，系统产生[缺页异常], 进入系统内核空间分配物理内存、更新进程页表。
    
- 外部内存碎片和内部内存碎片：
    由于页是事先划分好的，页与页之间紧密排列，所以不会有外部碎片。
    但是由于内存分配的最小单位是页(4KB)，会导致内部碎片。
    
- 换入和换出：
如果内存空间不足，系统会将其他进程中最近未被使用的页释放掉(由RAM写入硬盘)，称为```换出```。
一旦需要的时候，再加载进来，称为```换入```。
所以一次写入硬盘的只有少数页，内存交换的效率较高。
    
分页的使用可以使得在加载程序时，不需要一次性把程序加载到内存中。  
而可以在建立虚拟内存和物理内存的映射后(页表)，在程序需要时将部分指令和数据加载到物理内存中。
    
- 分页下物理地址和内存地址如何映射？
    - 虚拟地址分为两部分：页号和页内偏移
    - 页表包含物理页每页所在物理内存的基地址。
    
- 简单分页的缺点：
    - 32位下，虚拟地址空间4GB, 一页4KB。需要2^20个页。每个页表项4字节存储映射关系，整个4GB的映射就需要4MB的内存来存储。
    - 而整个操作系统同时运行多个进程，每个进程都有自己虚拟内存，整体开销巨大。
    
##### 二级分页
将2^20拆分为 1024个表，每个表包含1024个页表项。

由于实际进程并不会占用4GB内存，所以在建立一级页表(4KB)后，只有少部分二级页表在利用时被创建。  
从页表角度：页表职责是将虚拟地址映射为物理地址。所以页表一定需要覆盖全部虚拟地址空间。  
不分级页表覆盖需要2^20页，而二级页表只需要1024页，二级页表在进程运行时动态创建。
    
64位系统需要4级目录
- 全局页目录项
- 上层页目录项
- 中间也目录项
- 页表项
		
##### TLB(Translation Lookaside Buffer)
通常称为页表缓存、快表等。存储最常访问的页表项。  
多级页表虽然减少了空间消耗，但是转换工序增加带来了多余时间开销。  
程序访问的存储空间通常局限于某个内存区域。  

当CPU寻址时，先查TLB，没找到再常规扫页表。  
TLB的命中率考虑到程序实际访问的就几页，不低。
		
##### 段页式内存管理
分段和分页的组合使用就是段页式管理。

实现方式：  
- 先将程序划分为多个有逻辑意义的段。
- 再将每个段分为多个页。
- 地址结构由段号、段内页号、页内位移三部分组成。
	
段页式地址变换得到物理地址经过三次内存访问
- 第一次访问段表，得到页表起始地址
- 第二次访问页表，得到物理页号
- 第三次将物理页号和页内偏移组合，得到物理地址。
		
#### Linux内存
主要采用的是页式内存管理。  
Linux系统中每个段都是从0地址开始的整个4GB虚拟空间，这是为了配合intel的段式映射。

Linux操作系统中，虚拟地址空间分为**内核空间**和**用户空间**。  
32位操作系统内核空间占用1GB.

进程在用户态时，只能访问用户空间内存。
只有进入内核态，才能访问内核空间的内存。

每个进程虽然有独立的虚拟内存,但是每个虚拟内存中的内核地址，关联相同的物理内存。
		
- 用户空间：内存从低到高是6种内存段
    - 代码段(文本段)：	存储二进制可执行代码，所有函数都在这个段
    - 数据段(.data)：		已初始化的静态变量和全局变量
    - 数据段(.bss)：		未初始化的静态变量和全局变量(赋0值也放在这里)
    - 堆：				动态分配的内存，从低地址开始涨
    - 文件映射：			动态库、共享内存等(mmap内存就在这部分)。用于将文件直接映射到内存空间，用于I/O或进程间通信
    - 栈：				局部变量、函数调用的上下文等。栈大小固定，一般是8MB。
    
- 堆：
    - 位置：在数据段之上，增长方向向高地址
    - 操作系统以页面为单位为堆分配内存
- 栈
    - 位置：在虚拟地址空间的高地址端，增长方向向低地址
    - 也是以页面为单位分配
- 数据段
    - 位置：位于代码段之下，包含全局和静态变量
    - 数据段的一端是程序的"程序断点"，由brk或sbrk系统调用管理。指示了数据段的末尾位置

- 页面映射
    - 虚拟页到物理页：每个虚拟页通过页表映射到一个物理页面
    - 共享物理页：	多个虚拟页(来自不同进程)可以映射到同一个物理页(如共享库)
    - 独立物理页：	每个虚拟页大多映射到独立的物理页面

### 常见指针与内存管理错误
1. 悬挂指针： 	指向已释放内存的指针
2. 内存泄漏：	未释放不再使用的动态分配内存，导致内存资源浪费
3. 野指针：		未初始化或非法指向的指针，解引用会导致未定义行为
4. 双重释放：	同一块内存被释放多次，可能导致程序崩溃或安全漏洞

5. malloc如何分配内存？
	通过调用brk()和mmap()两种系统调用向操作系统申请堆内存。
	brk()从堆分配，mmap()在文件映射区分配。

##  4. 进程间通信方式
1. 管道
有名管道、匿名管道
2. 消息队列
允许进程以消息的形式进行通信，按照先进先出(FIFO)的顺序存储在队列中
- 队列存在内核空间的内存中
3. 共享内存
多个进程可以访问同一块物理内存区域，实现高效数据交换
- 数据通常是临时的，存放在内存中，进程终止后会丢失
- 适合快速共享大量数据的业务
- 通常位于进程的数据段或映射段(例如使用mmap映射)
4. 信号量(Semaphores)
用于进程同步或互斥，控制对共享资源访问。
使用系统调用如sem_post, sem_wait
工作机制：  
- 内部维护一个整数计数器，表示可用资源的数量
- P操作(等待):在请求资源时执行P操作，若信号量大于0，将其减1并继续执行，若等于0，阻塞等待
- V操作(释放)：释放资源时执行V操作，将信号量加1，并唤醒等待的进程。
5. 套接字(Sockets)
支持不同主机上的进程间通信，也可用于同一主机上进程间通信
6. 内存映射文件
- 将文件或其他对象映射到进程的地址空间，多个进程可以通过访问同一映射区来实现通信
- 由于映射文件，数据可以永久化存储在磁盘上。
- 适合需要数据持久化或跨应用共享数据的场景，如数据库缓存。也位于进程的数据段或映射段中
7. 远程控制调用(RPC)
允许一个进程(客户端)调用另一个进程(服务器)中的函数，就像调用本地函数一样。
8. 信号(Signals)
用于发送简单的通知或中断信号，通常用于控制进程的行为

### 匿名管道和有名管道
#### 匿名管道
- 没有名称，通常在父子进程间使用
- 创建后只能被相关进程使用
- 使用pipe()创建
#### 有名管道
- 有一个名称，通过该名称，多个不相关进程可以打开并通信
- 存在于文件系统中，可以在创建后被多个进程访问
- 使用mkfifo创建，存在于物理内存的内核态中的内存缓冲区

## 6. 调度算法
操作系统三大调度机制：进程调度、页面置换、磁盘调度算法
	
###	6.1 进程调度
也称CPU调度。当CPU空闲时，操作系统选择内存中某个就绪状态的进程，并分配给CPU.
发生CPU调度的情况：  
1. 进程从运行->等待(阻塞)
2. 运行->就绪
3. 等待->就绪
4. 运行->终止
		
#### 抢占调度和非抢占调度
发生在1、4情况下是非抢占式调度， 2，3是抢占式调度。
**非抢占** 的意思是：进程在完成或发生阻塞前会一直执行，才把CPU让给其他进程。
		
##### 常见的调度算法
1. 先来先服务(First Come First Served, FCFS)
- 当一个长作业运行，不利于后续排队的短作业。
- FCFS对长作业有利，适合CPU频繁型作业的系统，不适合I/O繁忙的系统。
2. 最短作业优先：
- 优先选择运行时长最短的进程运行。
- 对长作业非常不利。
3. 高响应比优先调度
每次进程调度时，先计算 响应比优先级， 将响应比优先级最高的进程投入运行。
```
响应比优先级 = (等待时间+服务时间) / 服务时间
```
4. 时间片轮转(Round Robin, RR)调度算法
每个进程被分配一个时间段，称为时间片。
- 如果时间片用完，进程还在运行，将此进程从CPU释放出来，并把CPU分配给另一个进程。
- 如果进程在时间片结束前阻塞或结束，则CPU立即进行切换。

- 时间片太短会导致过多进程上下文切换，降低CPU效率。
- 太长会引起短作业进程的响应时间变长。 

###### 进程优先级
进程优先级分为静态优先级和动态优先级。
- 静态优先级：
创建进程时已确定，整个运行时间优先级不会变化。
- 动态优先级：
根据进程动态变化调整优先级。比如进程运行时间增加就降低其优先级，等待时间增加就升高其优先级。
- 进程优先级处理方式
    - 非抢占式：	就绪队列出现高优先级的进程，运行完当前进程再选择。
    - 抢占式：	就绪队列出现高优先级进程，将当前进程挂起，调度优先级高的进程运行。
	
5. 多级反馈队列调度算法
- 多级：有多个队列，每个队列优先级从高到低，优先级越高时间片越短
- 反馈：有新的进程加入优先级高的队列时，立即停止当前正在运行的进程，去运行优先级高的队列。
		
### 6.2 页面置换
#### 缺页异常(缺页中断)
当CPU访问页面不在物理内存时，产生一个缺页中断，请求操作系统将所缺页调入物理内存。
    
- 缺页中断和一般中断的区别：

| 方面               | 缺页中断（Page Fault）                         | 一般中断（Hardware Interrupt）                            |
|--------------------|------------------------------------------------|-----------------------------------------------------------|
| 产生时机           | 在指令执行过程中访问内存时同步产生（同步异常） | 异步产生，通常由外部设备发出中断请求，CPU在指令完成后响应 |
| 中断响应时机       | 立即响应（指令执行期间检测到异常，暂停执行）   | CPU在当前指令执行完毕后检测到中断请求，才响应             |
| 处理后返回地址 | 返回到导致缺页的指令的起始地址，重新执行该指令 | 返回到被中断指令的下一条指令继续执行                      |

- 缺页中断时需要将所缺页资源加载到物理内存中
如果换入前发现物理内存中没有空闲页， 需要[页面置换算法]选择物理页换出磁盘。
    
页表项通常有如下字段：  
页号 物理页号 状态位 访问字段 修改位 硬盘地址  
- 状态位：	该位是否有效，即是否在物理内存中
- 访问字段：	该页在一段时间内被访问次数
- 修改位：	该页在调入内存后是否被修改过

#### 常见页面置换算法
页面置换的算法目标是尽可能减少页面的换入换出次数。
- 最佳页面置换算法
    - 置换在未来最长时间不访问的页面。
    - 实际系统中因为程序访问页面是动态的，无法预知每个页面在[下一次]访问前的等待时间。
    
- 先进先出置换(FIFO)
    - 置换在内存中驻留时间最长的页面
    
- 最近最久未使用
    - 最近最久未使用(LRU)

- 最不常用
    - LFU:选择访问次数最少的页面淘汰。
		
## 用户态和内核态切换
### 触发机制
#### 1. 系统调用 /软件中断
系统调用是用户态程序请求操作系统内核提供服务的机制，如文件操作、内存分配、进程管理等。  
触发过程：
1. 用户程序发起系统调用：通过特定接口如open()发起
2. 软件中断：用户程序执行一条特殊指令(x86架构中的 int 0x80)或使用syscall指令进入内核态
3. 陷入内核态：CPU切换到内核态，保存当前用户态的上下文
4. 内核处理请求：内核执行相应的系统调用服务
5. 返回用户态：完成服务后，恢复用户态上下文，切换回用户态继续执行程序。
#### 2. 中断
硬件设备(如鼠标、键盘、网络接口等)发出的信号，通知CPU需要处理的事件  
触发过程：
1. 硬件设备发出中断信号
2. CPU响应中断：当前指令执行完毕后，CPU暂停当前用户态程序，保存其上下文
3. 切换到内核态，执行对应的中断服务程序
4. 返回用户态
#### 3. 异常
程序执行过程中发生的异常情况，如除零错误、页错误、非法指令等  
触发过程：
1. 用户态程序执行导致异常的指令->CPU检测到异常后，暂停程序执行。
2. 进入内核态，执行相应的异常处理程序
3. 根据异常类型，内核可能终止程序、修复错误或采取其他措施
4. 处理完毕后，恢复用户态程序或终止程序运行
#### 4. 进程调度
操作系统在多个进程之间切换执行的机制，以实现多任务并发。  
触发过程：  
1. 时间片耗尽：一个进程的时间片用完，操作系统需要切换下一个进程
2. 中断触发调度：通常通过时钟中断触发调度程序
3. 保存当前进程状态
4. 选择下一个进程：根据调度算法选择下一个待执行的进程
5. 恢复新进程状态：加载新进程上下文信息，切换到内核态后再回到用户态执行新进程。

### 切换过程
1. 由触发机制切换到内核态
    - CPU切换到内核态
    - 保护当前用户程序的寄存器状态和程序计数器(Program Counter, PC)
2. 内核接管执行
    - 内核根据系统调用号找到相应的处理函数
    - 执行
3. 返回内核态
    - 内核通过特定指令(如sysret或iret)恢复用户态程序的寄存器状态和PC。
    - CPU切换回用户态，用户程序执行后续指令
### 代价和优化
1. 代价
    - 从用户态到内核态的切换涉及上下文保存与恢复、缓存失效等操作，增加时间开销
    - 频繁切换影响系统整体性能
2. 优化手段
    - 减少不必要的系统调用：优化应用程序，减少频繁系统调用
    - 批量处理：将多个操作合并为一个系统调用，降低切换次数
    - 使用内核空间资源：采用内核模块或驱动程序，将部分计算移至内核态，提高效率
			
## 8. 磁盘块
也称磁盘页，是磁盘存储的基本单位  
操作系统和数据库系统通常以块为单位进行磁盘读写操作。常见磁盘块大小为4KB。

### 磁盘块与内存页
- 内存页是操作系统管理内存的基本单位，与虚拟内存有关。
- 内存页的典型大小也为4KB，与磁盘块大小相匹配，以便高效地在内存和磁盘间进行数据交换。

## 7. 高并发场景下如何不用锁和信号量实现互斥访问？
思路：使用原子操作和CAS(Compare-And-Swap)
使用原子指针指向当前共享数据。
- 所有读操作通过读取这个指针来获取数据的状态
- 写操作通过创建数据的副本，修改副本，然后通过CAS将原子指针更新为新副本
- 如果CAS失败，说明有其他写操作已经修改了数据，此时需要重试。

- 为了避免数据副本在被读取时销毁，可以采用引用计数。

CAS：比较并交换
- 通过比较内存中的值与预期值，如果相同，更新内存中的值，否则不执行更新操作。
- CAS属于原子操作
- 详细操作步骤：
    1. 读取内存位置V中的当前值
    2. 比较：检查当前值是否等于预期值A
    3. 条件更新：	相等，将V的值更新为B
                    不等，不执行更新操作
    4. 返回操作是否成功
	
