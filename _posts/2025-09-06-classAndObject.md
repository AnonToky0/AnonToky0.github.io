---
title: "C++ 类和对象"
date: 2025-08-25 23:00:00 +0800
categories: [C++]
tags: [C++]
---

## 成员函数(Member Functions)
定义在类内部，用来操作类的对象（实例）的函数。
分为普通成员函数、虚成员函数、静态成员函数、特殊成员函数、常成员函数(const修饰)等。

| 成员函数类型 | 说明   | 是否算作普通成员函数 |
|--------------|-------------------|-------------------|
| 普通成员函数 | 无`virtual`，非静态成员函数           | 是   |
| 虚成员函数   | 使用`virtual`声明，支持多态           | 否   |
| 静态成员函数 | 使用`static`声明，不属于对象实例       | 否  |
| 特殊成员函数 | 构造函数、析构函数、赋值运算符等特殊函数 | 也可以是普通成员函数，但通常单独分类 |

## 特殊成员函数
- 默认构造函数
- 拷贝构造函数
- 移动构造函数
- 赋值运算符重载（拷贝赋值、移动赋值）
- 析构函数
这些函数可以是编译器自动生成的，也可以由程序员自定义。

- 在类内定义的成员函数默认是内联的，编译器会尝试优化成内联调用。
- 成员函数可以重载
- 成员函数可以是模板函数，支持泛型编程。

## 构造函数
### 拷贝构造函数
- 拷贝构造函数的职责是用一个已有对象来初始化一个新对象。
- 标准库和编译器默认生成的拷贝构造函数是浅拷贝，即逐成员复制（成员逐个按值复制），如果成员是指针，则只复制指针的地址，不复制指针指向的内容。
- 只有当类管理动态资源时，程序员才需要自定义拷贝构造函数来实现**深拷贝**，避免多个对象共享同一资源导致的问题。

``` cpp
class MyClass {
private:
    int* data;

public:
    // 构造函数
    MyClass(int value) {
        data = new int(value);
    }
	// 自定义拷贝构造函数（实现深拷贝）
    MyClass(const MyClass& other) {
        data = new int(*other.data);  // 申请新内存，复制值
    }
    // 析构函数
    ~MyClass() {
        delete data;
    }
};

int main() {
MyClass obj1(10);       // 调用构造函数
MyClass obj2 = obj1;  	// 调用拷贝构造函数，深拷贝

}
```

- **注意**
	- 拷贝构造函数只负责初始化对象内部成员，它不负责分配对象本身的内存。
	- 对象本身的内存由声明对象的方式决定：局部变量通常在栈上，动态分配的对象在堆上。

### 三法则和五法则
“三法则”和“五法则”是C++中关于类的特殊成员函数的设计原则，主要用于管理类中资源（如动态内存、文件句柄等）的正确拷贝、赋值和销毁，避免资源泄漏、悬空指针等问题。

#### 三法则
如果一个类管理了动态资源（比如用裸指针new了内存），需要自定义以下三个特殊成员函数：
1. 拷贝构造函数 (Copy Constructor)
用于通过已有对象初始化新对象，负责**深拷贝**资源
2. 拷贝赋值运算符 (Copy Assignment Operator)
用于给已存在对象赋值，负责释放旧资源、深拷贝新资源。
3. 析构函数 (Destructor)
用于对象销毁时释放资源，防止内存泄漏。

#### 五法则


### 空类
一个类没有非静态数据成员、没有虚函数、没有虚基类。**只看非静态数据成员和虚函数**来判断
- 成员函数（包括普通成员函数）不算数据成员，它们不占对象的存储空间。
- 静态成员也不算对象的组成部分。
- 虚函数会导致类有虚表指针，会增加对象大小，不算空类。

``` cpp
class Empty {
public:
    void foo() {}
};
```
这个类仍然是空类。

C++为空类自动实现的函数包括：
- 默认构造函数
- 默认析构函数
- 拷贝构造函数
- 移动构造函数
- 拷贝赋值运算符：将一个已有对象的内容赋值给另一个对象
- 移动赋值运算符
		
空类的大小至少为1字节。这是由C++标准决定的，确保每个对象有唯一的地址。
	
#### 空基类优化 (Empty Base Optimization, EBO)
当空类作为其他类的基类时，编译器可能会应用空基类优化，从而使继承类的大小不因空基类而增加。
比如  
``` C++
class Empty {};

class parent: public Empty
	{
		int val;
	};
```
parent带有一个4字节的val，但parent类可能只占4字节。

- 如何实现的？
由编译器使用EBO, 在内存布局中，把空基类子对象的地址设置为派生类对象的起始地址（或与其他成员重叠）。  
由于空类没有数据成员，不会访问其成员数据，访问空基类部分不会产生冲突。