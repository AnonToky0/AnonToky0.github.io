---
title: "HTTP & HTTPS"
date: 2025-08-29 9:30:00 +0800
categories: [计算机网络]
tags: [HTTP, HTTPS]
---

#### 参考
1. [小林Coding:图解网络](https://xiaolincoding.com/network/2_http/http_interview.html)

## HTTP
HyperText Transfer Protocol, 超文本传输协议。HTTP定义了请求和响应的格式和规则，使得不同计算机和平台之间能有效通信。  
HTTP 是一个用于在两点间传输 文本、图片、音频、视频等超文本数据的约定和规范。  
HTTP默认使用80端口

#### HTTP工作原理
1. 客户端发起HTTP请求：用户在浏览器中输入URL，浏览器解析URL，提取域名和资源路径
2. DNS查询：递归查找：浏览器缓存->操作系统缓存->DNS解析器=>DNS服务器->根DNS服务器->TLD服务器->权威DNS服务器->查到IP返回
3. 建立TCP连接，默认80端口
4. 浏览器发送HTTP请求报文，包括**请求行**、请求头、请求体
5. 服务器接受请求，处理后生成HTTP响应报文
6. 服务器发送HTTP响应报文，包括**状态行**、响应头、响应体
7. 根据HTTP版本和连接头，决定是否关闭连接或复用连接
8. 浏览器根据响应内容宣传页面，显示给用户

### HTTP请求
#### HTTP请求格式
HTTP请求格式由三部分组成：请求行、请求头字段和请求体（可选）。
```
请求行
请求头字段
空行
请求体（可选）
```
##### 1. 请求行
```
<请求方法> <请求URI> <HTTP版本>
```
例如：  
```
GET /index.html HTTP/1.1
```

> **[安全]**: 请求方法不会破坏服务器上资源
> **[幂等]**：多次执行相同的操作，结果都是相同的
##### 常见请求方法
- GET：	请求访问指定的资源，通过URL传递参数，适用于获取数据。  
	- GET请求的参数位置一般写在URL中，参数放在`?`后面，形成查询字符串。
	- GET请求参数暴露在URL中，不适合传递敏感信息。
	- URL规定只能支持ASCII。
	- 特点：
		- 幂等、安全
		- 缓存：GET请求可以被缓存，也可以在浏览器中被保存为书签
- POST：向服务器提交数据，通常用于创建新资源，请求数据一般写在请求body中。
	- 特点：
		- 非幂等、非安全：多次相同的POST可能导致创建重复资源
		- 不被缓存：默认下POST不被缓存，也不能保存为书签
- PUT：	更新或替换指定的资源，如果资源不存在，根据服务器实现可能创建新资源
	- 特点：
		- 幂等
		- 包含数据
- DELETE： 删除指定的资源
	- 特点：
		- 幂等
		- 安全性
- HEAD：		与GET类似，但服务器只返回头部信息
- TRACE：		回显服务器收到的请求，主要用于调试
- CONNECT：	建立与服务器的隧道连接，常用于HTTPS通过代理服务器的情形

###### GET和POST请求区别
1. 作用：
GET从服务端获取资源, POST向服务器提交数据
2. 参数传递方式
GET请求参数一般写在URL中，且只接受ASCII字符,POST请求参数放在请求体中，对数据类型没有限制
3. 安全性
- GET请求参数暴露在URL中，更不安全
- **注意**：由于HTTP明文传输，所以虽然浏览器URL看不到Body数据，但是抓包仍能获取Body内容	
4. 参数长度限制
GET不能大于2KB, POST一般不受限
5. 缓存机制
- GET请求会被浏览器主动缓存，POST不会
- 请求参数完整保留在浏览器历史记录里，POST中参数不会保留
- GET产生的URL地址可以被保存为书签
- GET在浏览器回退是无害的，而POST会再次提交请求
6. 时间消耗
- GET请求没有请求体，或者请求体非常小，浏览器把请求头和请求数据一起发送,服务器收到请求后，处理完毕直接返回HTTP状态码200(OK)和响应内容。
- POST请求通常会带有请求体，浏览器可能先发送请求头部分， 服务器响应100 continue， 浏览器再发送请求体，服务器响应200(Ok)

### HTTP响应
#### HTTP响应格式

```
状态行
响应头1: 值1
响应头2: 值2
...

响应体（可选）
```

##### 状态行
响应报文的第一行(状态行)，依次是当前HTTP版本号，3位数字组成的状态码，及描述状态的短语，例如
```
HTTP/1.1 200 OK
```
#### HTTP状态码
- 1XX: 请求已被接收，正在处理
- 2XX: 成功接收、理解和处理
- 3XX: 重定向状态码：需要客户端进一步操作
- 4XX: 客户端错误：请求包含错误
- 5XX: 服务器错误：服务器在处理请求时出现错误

##### 1XX	信息性状态码
100 continue: 初始请求已收到，客户端继续发送其余部分

##### 2XX	成功
- 200 OK : 		请求已成功处理，服务器返回了请求资源
- 201 Created:	请求成功并创建了新资源，通常在POST后返回，包含新资源的URL
- 204 No ConTent:	请求成功处理但没有内容返回给客户端，常用于DELETE或PUT请求更新资源
- 206：成功处理部分GET请求，返回资源的一部分，用于HTTP分块下载或断点续传

##### 3XX 重定向
- 301 Moved Permanently：	永久重定向，资源已永久移动到新的URL。
- 302 Found:				临时重定向，资源临时移动到另一个URL，用于临时性页面重定向，如登录后跳转
- 304 Not Modified:		资源未修改，客户端可以使用缓存版本

##### 4XX 客户端错误
- 400 Bad Request：	请求格式错误
- 401 Unauthorized:	请求未经授权，客户端需要身份验证
- 403 Forbidden: 服务器理解了客户端的请求，但拒绝执行该请求  
	可能的原因：客户端权限不足，IP被封禁，只允许特定用户访问，禁止目录浏览，访问频率限制等
- 404 Not Found:		请求的资源在服务器上未找到
	
##### 5XX 服务器错误
- 500 Internal Server Error:	服务器内部错误
- 501 Not Implemented: 服务器请求的功能暂时不支持
- 502 Bad Gateway:			**错误网关**，服务器作为网关或代理时，从上游服务器收到无效响应
- 503 Serive Unavailable:		**服务不可用**，服务器暂时无法处理请求，通常由于过载或维护
- 504 Gateway Timeout:		**网关超时**，服务器作为网关或代理时，上游服务器未及时响应

### HTTP头字段
HTTP头字段是附加在HTTP请求和响应中的键值对，用于传递关于客户端、服务器、请求和响应主体的元数据。  
分为三类：通用头字段(适用于请求和响应)，请求头字段， 响应头字段

#### 通用头字段：
- Cache-Control: 		缓存机制
- Connection:			是否保持持久连接(长连接)
- Pragma:				向后兼容HTTP/1.0的缓存指令
	
##### 请求头字段：
- Host:				请求的目标主机和端口
- Accept: 客户端可以接收的数据格式
- Accept-Encoding: 客户端可以接受的压缩方法
```
Accept: */*
```

##### 响应头字段：
- Cache-Control: 		缓存机制
- Content-Encoding:	响应体使用的压缩算法

```
Content-Encoding: gzip
```
- Content-Length:		响应体的字节长度
- Content-Type:		响应体的数据格式和编码， 如： 

```
Content-Type: text/html; charset=UTF-8
```

> 长连接：任意一端没有明确提出断开连接，则保持TCP连接状态  

HTTP/1.1 版本默认连接都是长连接，为了兼容老版本，需要指定值

```
Connection: Keep-Alive
```

长连接状态下，客户端发送另一个请求时，会使用同一个连接，持续到一端提出断开连接。

###  HTTP缓存技术

---

对于具有重复性的HTTP请求，比如每次请求得到的数据都是一样的，可以将请求-响应的数据缓存在本地，下次可以直接读取本地数据，不必通过网络获取服务器响应。  
缓存可以：
- 减少不必要的网络传输，节约带宽
- 更快加载页面
- 减少服务器负载
HTTP 缓存有两种实现方式，分别是**强缓存**(强制缓存)和**协商缓存**。

### 强缓存
浏览器判断请求的目标资源是否有效命中强缓存，命中从内存中读取目标资源，无需与服务器通讯。
强缓存利用以下两个HTTP响应头字段实现，都表示资源在客户端缓存的有效期

```
Expires：绝对时间
Cache-Control： 相对时间
```

- `Expires`：设置一个强缓存时间，在此时间范围内 从客户端内存中读取缓存并返回  
- `Cache-Control`: http1.1中增加，在资源的响应头上写上需要缓存多久，单位秒
如果同时有以上两个字段，Cache-Control 优先级高于 Expires。

#### `Cache-Control`实现流程
- 浏览器第一次请求服务器资源，服务器返回资源时在响应头部加上`Cache-Control`，设置了过期时间大小；
- 浏览器接收到响应后，会根据Cache-Control的规则将响应内容保存到本地缓存（内存缓存或磁盘缓存），并记录下缓存的过期时间。
- 浏览器再次请求，会检查本地缓存，通过请求资源的时间与`Cache-Control`中设置的过期时间，计算该资源是否过期，没有则使用该缓存，否则重新请求服务器
- 服务器再次收到请求后，会更新响应头的`Cache-Control`

### 协商缓存
用来在缓存内容过期或不确定是否过期时，通过与服务器协商确认缓存资源是否仍然有效，从而决定是否使用缓存或重新下载资源。协商缓存可以基于两种头部来实现。
#### 1. 基于last-modified的协商缓存
基于请求头的`If-Modified-Since`和响应头的`Last-modified`。
`Last-modified`标识 这个响应资源的最后修改时间

具体流程：  
- 服务端收到请求后，在服务器端读出文件修改时间
- 将读出来的修改时间赋给响应头的`Last-modified`字段
- 设置Cache-Control: no-cache
- 客户端读取到`Last-modified`，在下次的请求头中携带字段：`If-Modified-Since`,字段的值就是之前服务器返回的 `Last-Modified` 时间。
- 服务端解析出有`If-Modified-Since`字段，拿到这个时间并与该资源的最后修改时间做比较；
- 如果最后修改时间较新(大)，说明资源又被改过，返回最新资源和200；否则返回304走缓存

缺点：
- 在文件内容不修改情况下文件修改时间依然可能更改(如修改文件名)，导致缓存失效
- 当文件在极短时间内完成修改，由于修改时间字段记录单位为秒，导致判定文件修改时间不变
- 有些服务器不能精确获取文件的最后修改时间

#### 2. 基于`ETag`的协商缓存
基于请求头的`If-None-Match`和响应头的`ETag`  
将原来协商缓存比较时间戳的形式改为比较文件指纹(根据文件内容计算出的唯一哈希值)  
- 服务器第一次收到文件请求时，读取文件指纹，放在响应头的`ETag`字段返回给客户端
- 第二次请求时，客户端将上一次服务器返回的`ETag`赋给请求头的`If-None-Match`字段
- 服务器拿到请求头的`If-None-Match`, 再次读取文件指纹并对比
	- 如果文件指纹吻合，返回304状态码和一个空的响应体并return
	- 如果文件指纹不吻合，将新的文件指纹赋到响应头的ETag字段返回给客户端
- 缺点:
	- 计算文件指纹需要更多计算开销
	- 计算频繁会影响服务器性能
	- ETag有强验证和弱验证，强验证保证文件每个字节都一致，弱验证提取文件部分属性，速度快但准确率低

#### 优先级 & 注意事项
- 如果服务端返回的响应头部同时带有`Last-Modified`和`ETag`，下次客户端发送请求带上`If-Modified-Since`和`If-None-Match`，`ETag`的**优先级更高**。
即先判断ETag是否变化，如果ETag没变化，再判断`Last-Modified`。

- 协商缓存这两个字段都需要配合强缓存的 `Cache-Control`。只有未命中强缓存，才能发起带有协商缓存字段的请求。


- 有哈希值的文件设置强缓存，没有哈希值的文件(比如index.html)设置协商缓存
> 内容哈希，指根据文件内容通过哈希算法（如 MD5、SHA-1、SHA-256 等）计算出来的一段固定长度的字符串，用来唯一标识该文件的内容。
有哈希值的文件，指的就是文件名中带有内容哈希（content hash）的静态资源。  
这种文件名的哈希值是根据文件内容生成的，只要文件内容不变，哈希值就不变；一旦内容变了，哈希值也会变，文件名也会变。
	- 为什么设置强缓存？
	因为文件名一旦改变，浏览器就会请求新的文件，这样可以让浏览器对这些带哈希的资源设置很长时间的强缓存（如 Cache-Control: max-age=31536000 一年），避免重复请求。

## HTTP 特性
HTTP 目前版本有 HTTP/1.1, HTTP/2.0, HTTP/3.0

### HTTP/1.1
#### HTTP/1.1 优点
1. 简单
报文格式为 `header+body`,头部信息为`key-value`
2. 灵活和易于扩展
各类请求方法、URL、状态码、头字段等组成要求没有被固定死，允许开发人员自定义和扩充。  
同时由于HTTP工作在应用层，允许下层变化，比如：
- HTTPS在HTTP和TCP之间增加了SSL/TLS 安全传输层
- HTTP/1.1 和 HTTP/2.0 传输协议用的是TCP协议，HTTP/3.0改用UDP协议。
3. 应用广泛，跨平台

#### HTTP/1.1 缺点
1. 无状态
- 无状态的好处是服务器不需要额外资源记录状态信息
- 坏处是在完成有关联性的操作时非常麻烦。
	- 比如购物等需要验证身份的请求，服务器需要每次都验证身份信息。

- **Cookie**
`Cookie`在请求和响应报文中写入Cookie信息来控制客户端状态。  
客户端在第一次请求后，服务端会在响应中添加Cookie，后续客户端请求服务器时带上Cookie供服务器识别。

2. 明文传输
3. 不安全
- 使用明文通信，内容可能被窃听
- 不验证通信方的身份
- 无法保证报文的完整性

### HTTP/1.1 性能
基于 TCP/IP，并且使用请求-应答的通信模式。
1. 长连接
HTTP/1.0 性能的一大问题是每次请求-应答都要新建一次TCP连接(三次握手)，而且是串行请求，增加了无谓的通信开销。
> 串行请求：一个请求发送后，必须等待服务器完整响应（包括响应头和响应体）返回后，才能发送下一个请求。

为了解决该问题，HTTP/1.1提出了长连接，也叫持久连接。
持久连接的特点是只要一方没有明确提出断开连接，则保持TCP连接状态。
- 如果某个HTTP长连接超过一定时间没有任何数据交互，服务端会主动断开这个连接。

2. 队头阻塞
HTTP/ 1.1 支持管道传输技术，即可在同一个TCP连接里，客户端可以并行发起多个请求，减少整体的响应时间。
- **队头阻塞(Head-of-line blocking)**
服务器必须按照客户端发送的顺序发送对这些管道请求的响应。  
如果第一个请求的响应很慢，后续请求的响应即使准备好了，也必须等待前面响应完成。这称为队头阻塞。
> TCP层保证数据包顺序到达，从服务器应用层角度看，接收到的请求顺序与客户端发送顺序一致。

 - **注意**
 HTTP/1.1 管道技术**不默认开启**，且浏览器基本不支持。

## HTTPS

---

HTTPS是基于HTTP协议之上，通过SSL/TLS协议为通信提供加密和身份验证的安全协议。  
HPTTS默认使用**443**端口

### HTTPS工作原理
1. 客户端发起HTTPS请求，发送支持的TLS版本、加密算法列表、随机数等
2. 服务器选择TLS版本和加密算法，并将其TLS版本、选择的密码套件、SSL数字证书(包括公钥)发送给客户端，发送服务器随机数,公钥包裹在证书中
3. 客户端使用CA的公钥验证服务器证书的有效性，包括证书链、签名和到期时间；如果验证失败，客户端提示安全警告
4. 客户端生成一个随机的会话密钥，用服务器的公钥加密后发送给服务器：使用非对称加密确保会话密钥仅服务器能解密
5. 服务器使用私钥解密出会话密钥，基于随机数生成对称密钥，二者从此使用该对称密钥进行对称加密通信
6. 客户端和服务端使用会话密钥进行加密和解密，确保后续数据传输的安全性
	
### SSL/TLS
SSL/TLS (Secure Sockets Layer), (Transport Layer Security)是用于在计算机网络中提供安全通信的加密协议。  
TLS是SSL的后续版本，具有更高的安全性和性能优化。  
HTTPS主要基于TLS协议实现安全传输

### 证书颁发机构(Certificate Authority)
CA是可信的第三方实体，负责签发和管理数字证书。常见CA包括Let's Encrypt

### 安全问题
1. 中间人攻击(Man-in-the-Middle, MITM)  
中间人攻击指攻击者在客户端和服务器之间插入自己，拦截、篡改或窃取双方的通信数据。
攻击者试图诱导客户端与其建立加密连接，而不是与目标服务器直接通信。  
	- 常见中间人攻击方法：
		1. 伪造证书：	生成假冒的SSL/TLS证书，试图欺骗客户端
		2. DNS劫持：	篡改DNS解析，将合法域名解析到恶意服务器的IP地址
		3. ARP欺骗：	欺骗ARP表，将目标设备的流量导向自己。  

	- 防护措施：
		1. 证书验证：客户端严格验证服务器的SSL/TLS证书
		2. 使用HSTS(HTTP严格传输安全)：强制客户端通过HTTPS连接，防止降级攻击
		3. 启动证书钉扎：在客户端代码中预先定义受信任的证书或公钥。
		4. DNSSEC:	启用DNS安全扩展

2. SSL/TLS 漏洞
	- SSL 3.0 填充模式的缺陷
	- OpenSSL实现中的 缓冲区溢出漏洞
	- TLS 1.0及更低版本中的块加密模式漏洞

## HTTP 与 HTTPS

---

### 共同点
都是应用层协议，广泛用于Web浏览、数据传输和在线服务。
### HTTP 与 HTTPS 有哪些区别？
- HTTP 是明文传输，存在安全风险问题。HTTPS在 TCP 和 HTTP网络层之间加入了SSL/TLS安全协议，使得报文可以加密传输。
- HTTP 连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 默认端口不一样， HTTP默认端口 80， HTTPS 默认端口 443。
- HTTPS 协议需要向CA (证书权威机构)申请数字证书，来保证服务器的身份是可信的。

### 安全问题
#### HTTP的安全问题
由于 HTTP 明文传输，安全上存在以下风险：
- 窃听： 通信链路上可以获取通信内容
- 篡改： 比如强制植入垃圾广告
- 冒充： 比如冒充购物网站

#### HTTPS如何解决安全问题
利用SSL/TLS 协议：  
- 信息加密：采用**混合加密**
- 校验机制：采用摘要算法，为数据生成独一无二的指纹，用于校验数据的完整性。
- 身份证书：将服务器公钥放入到数字证书中

##### 1. 混合加密
HTTPS 采用对称加密和非对称加密结合的混合加密方式：
- 在通信建立前采用 非对称加密 交换[会话密钥]
- 在通信过程中全部使用对称加密的[会话密钥]的方式加密明文数据

**采用混合加密的原因**  
- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

##### 非对称加密
共有两个密钥：
- 公钥：可以公开给所有人
- 私钥：由本人管理，不可泄露

双向加解密：可以用公钥加密内容，然后用私钥解密；也可以用私钥加密内容，然后用公钥解密  
- 公钥加密，私钥解密：可以保证传输内容安全，只有持有私钥的人才能解密出实际内容
- 私钥加密，公钥解密：可以保证消息不被冒充：因为私钥不可泄露，如果公钥能正常解出私钥加密的内容，就能证明内容是来源于持有私钥身份的人发送的。

- 传输内容不使用非对称加密：
非对称加密的计算比较耗费性能。

##### 2. 摘要算法 + 数字签名
为了保证传输内容不被篡改，需要对内容计算出一个指纹，然后同内容一起传输给对方。  
对方收到后，也根据内容计算出一个指纹，然后跟发送方发送的指纹做比较，如果指纹相同，说明内容没有被篡改。

- **摘要算法**
采用摘要算法(哈希函数)计算出内容的哈希值，也就是内容的指纹，这个哈希值唯一，且无法通过哈希值推导出内容。

- 注意
采用哈希函数可以保证内容不被篡改，但不能保证内容+指纹不被中间人替换，即缺少客户端接收到消息是来自于服务端的证明。

- 确认消息来自于服务端：
采用非对称加密算法，使用私钥加密，公钥解密来确认消息来自目标服务端。  
**数字签名算法**：利用私钥对哈希值进行加密，客户端通过公钥解密出哈希值，并与自己计算出内容的哈希值进行比对，如果相同，证明内容完整没有被篡改过。

##### 3. 数字证书
哈希算法和数字签名可以保证消息的完整性和消息来源可靠，但是仍需要**身份验证**，来确保公钥不是被伪造的。

数字证书由权威的第三方机构(证书颁发机构，CA)签发，绑定了持有者身份信息和公钥。
具体工作原理：
- 服务端将公钥与身份信息一起提交给CA，申请数字证书。
- CA验证申请者身份后，将用户的身份信息和公钥打包，使用自己的私钥对这些信息进行数字签名，生成数字证书。交给服务端
- 服务端将证书交给客户端，客户端通过CA的公钥验证数字证书上的签名，确认证书没有被篡改，且确实由可信CA签发。
- 通过证书中的服务端的公钥进行加密通信或身份验证。
- 证书验证包括验证证书有效期，证书是否被吊销，和证书链等。

### HTTPS 如何建立连接
SSL/TLS 协议基本流程：
- 客户端向服务器索要并验证服务器的公钥
- 双方协商生产[会话密钥]
- 双方采用[会话密钥]进行加密通信

SSL/TLS 握手，也就是前两步安全参数协商，发生在TCP三次握手之后，传输加密的应用数据之前。

#### TLS 握手
涉及四次通信。常用的密钥交换算法有两种：RSA算法和ECDHE算法。
1. ClientHello
首先，由客户端向服务器发起加密通信请求，即`ClientHello`请求。
主要向服务器发送以下信息：  
- 客户端支持的TLS版本，如 TLS 1.2版本
- 客户端生产的随机数(`Client Random`)，用于后续生成[会话密钥]条件之一
- 客户端支持的密码套件列表，如RSA加密算法

2. ServerHello
服务器收到客户端请求后，向客户端发出相应，即`ServerHello`。
主要向客户端回应如下内容：
- 确认TLS版本，如果浏览器不支持，则关闭加密通信
- 服务器生产的随机数(`Server Random`), 也是用于后续生成[会话密钥]的条件。
- 确认的密码套件列表，如RSA 加密算法
- 服务器的数字证书

3. 客户端回应
客户端收到回应后，首先通过浏览器或操作系统中的CA公钥，确认服务器的数字证书的真实性。
证书如果没有问题，客户端从数字证书中取出**服务器的公钥**，使用它加密报文，向服务器发送以下信息：  
- 一个随机数(`pre-master key`)。该随机数会被服务器公钥加密。
- 加密通信算法改变通知，表示随后的信息都将使用[会话密钥]加密通信
- 客户端握手结束通知，表示客户端的握手阶段已结束。同时把之前所有内容的发送的数据做个摘要，供服务端校验

服务端和客户端有了这三个随机数(`Client Random`, `Server Random`, `pre-master key`),接着用双方协商的加密算法，各自生成本次通信的[会话密钥]。

4. 服务器回应
服务器收到客户端的第三个随机数之后，通过协商的加密算法，计算出本次通信的[会话密钥]。
然后，向客户端发送最后的信息：
- 加密通信算法改变通知，随后信息都将用[会话密钥]加密通信
- 服务器握手结束通知，表示服务器的握手阶段已结束。同时把之前所有内容的发送的数据做个摘要，供客户端校验。

接下来，客户端与服务器进入加密通信，使用普通的HTTP协议，但是用[会话密钥]加密内容。

### 数字证书签发和验证流程
#### 数字证书签发
- CA 把域名持有者的公钥、用途、颁发者、有效时间等信息打成一个包，对这些信息进行Hash计算，得到一个Hash值。
- CA 使用自己的私钥将该Hash值加密，生成证书签名(Certificate Signature)。
- 最后将证书签名添加在文件证书上，形成数字证书。

#### 客户端校验证书
- 客户端使用相同的Hash算法获取该证书的Hash值 H1
- 通常浏览器和操作系统中集成了CA的公钥，收到数字证书后，使用公钥解密证书签名，得到一个Hash值 H2
- 比较 H1 和 H2，如果值相同，则为可信赖。

#### 证书信任链
申请证书一般不是根证书签发，而是由中间证书签发的。  
而浏览器或操作系统中保存的是根证书的公钥信息。  

多层级(三级层级)证书验证过程：  
- 检查服务器证书，发现由中间CA签名，请求中间证书
- 检查中间证书，发现由根CA签名，根据根证书的公钥验证中间证书是否可信
- 中间证书被信任后，用中间证书的公钥验证 服务器证书的可信性，验证通过证明服务器证书可信。

##### 为什么需要证书链？
- 确保根证书的绝对安全性，而将根证书隔离地越严格越好。

### HTTPS应用数据如何保证完整性
TLS在实现上分为**握手协议**和**记录协议**。
- 握手协议负责四次握手，协商加密算法和生成对称密钥。
- 记录协议负责保护应用数据并验证其完整性和来源。

#### 记录协议
主要负责消息(HTTP数据)的压缩，加密及数据验证。
- 首先，消息被分为多个片段，分别压缩。
- 经过压缩的片段会被加上消息认证码(Message Authentication Code, MAC值，通过哈希算法生成)。通过附加消息认证码的MAC值，可以识别出篡改。同时，为了防止重放攻击，在计算消息认证码时，加上片段的序号编码。
> 消息认证码是一种通过哈希算法和密钥对消息内容生成的固定长度的“指纹”或“摘要”
> 重放攻击：截获网络上的有效数据包（消息），然后重复发送这些数据包，以欺骗接收方执行重复的操作。
- 经过压缩的片段再加上消息认证码一起通过对称加密进行加密。
- 最后，上述经过加密的数据再加上报头(记录头)就是最后的报文数据。
> 这里说的报头是TLS记录协议的报头(`Record Header`)，是TLS层一个固定格式的5字节头部。包括： 
- 内容类型(Content Type，如握手、应用数据等)
- 版本号(TLS版本)
- 长度(加密后数据长度)

记录协议完成后，报文数据传递到TCP层进行传输。

### HTTPS一定安全可靠吗？
假设存在中间人服务器代理，或者说有假基站将客户端请求转发给中间人服务器。
中间人服务器分别和客户端和服务器建立TLS连接，此时中间人能获取客户端和服务器发送的所有数据。

#### 场景假设
这种情况发生的前提是用户接收了中间人服务器的证书。
中间人服务器与客户端在TLS握手过程中，发送了自己伪造的证书给浏览器，这个伪造证书是可以被客户端识别出非法的。

或者，由于电脑中毒，被恶意导入了中间人的根证书，也可能验证出中间人证书合法。 

#### 为什么抓包工具能截取HTTPS数据

- **中间人明文代理**的条件
- 中间人和服务端通信：由于服务端不验证客户端的身份，可以正常建立连接
- 中间人和客户端连接：需要客户端信任中间人服务端，即服务端有对应域名的私钥。

中间人如何拿到私钥？  
1. 拿到真正服务端的私钥
2. 从CA处获得签发证书，即申请到针对该域名的证书
3. 自己签发伪造证书，并让客户端信任这个伪造CA

抓包工具采用第三种方式：  
使用抓包工具进行 HTTPS 抓包，需要在客户端安装抓包工具(如Fiddler)的根证书。

#### 如何避免中间人攻击(被中间人抓取数据)
- 不要信任中间人证书；
- 防止病毒入侵，被恶意导入中间人根证书；
- HTTPS双向认证： 要求服务器验证客户端身份

