---
title: "数据库"
date: 2025-08-26 16:40:00 +0800
categories: [数据库]
tags: [数据库]
---
主要介绍MYSQL  
MYSQL架构分为两层：Server层和存储引擎层

- Server层负责建立连接、分析和执行SQL
    - 主要包括连接器、查询缓存、解析器、预处理器、优化器、执行器等

- 存储引擎层负责数据的存储和提取
    - 现在最常用存储引擎为InnoDB.
    - 索引存储结构就是由存储引擎层实现的。
    - InnoDB支持索引类型为B+树，即在数据表中创建的主键索引和二级索引 默认使用的是B+树索引
		
## 1. 一条select语句是如何执行的
以以下语句为例:
``` MYSQL
select * from product where id=1
```
表示从product 表中查找id为1 的所有列(*代表通配符)
也可以明确具体列，比如
``` MYSQL
SELECT name, price FROM product WHERE id=1;
```
	
创建数据库
```
CREATE DATABASE my_database;
```

使用数据库
```
USE my_database;
```

创建表
```
CREATE TABLE users (
id INT AUTO_INCREMENT PRIMARY KEY,
username VARCHAR(50) NOT NULL,
email VARCHAR(100),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

列名， 数据类型， 属性
	
	
1.连接器：
mysql -h$ip -u$user -p
输入passward

MYSQL基于TCP协议进行传输

如何查看MYSQL服务被多少客户端连接?
    show processlist

空闲连接(command列状态为sleep)会一直占用吗？
    由wait_timeout参数控制，默认28880秒(8小时)
    
显示参数
    show variables like 'wait_timeout'
    
手动断开空闲连接
    kill connection +$id
    
MYSQL连接有限制吗？
    最大连接数由max_connnections参数控制

MYSQL的短连接和长连接
    短连接在执行所需的SQL操作后立即关闭连接，每次都要三次握手和四次挥手
    所以一般推荐长连接：客户端与数据库服务器建立一个持续的连接
    
### 怎么解决长连接占用内存的问题？
MYSQL在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放
1. 定期断开长连接
2. 客户端主动重置连接
    在代码中调用mysql_reset_connection

2. 查询缓存
    连接建立后：客户端向MYSQL服务器发送SQL语句。解析SQL语句的第一个字段：
    
        查询语句(SELECT):先去查询缓存(Query Cache)里查找缓存数据
            查询缓存以key-value形式保存在内存中，key为SQL查询语句，value为SQL语句查询结果
            命中查询缓存就直接返回value给客户端, 没命中就向下继续执行
            
    只要一个表有更新操作，这个表的查询缓存就会被清空。
    所以MYSQL 8.0 !!!去掉了!!! 查询缓存
    
    通过将参数 query_cache_type设置为DEMAND来关闭查询缓存
		
3. 解析SQL
    在执行SQL语句之前对SQL语句进行解析，由解析器完成
    
    3.1 词法分析：根据输入字符串识别出关键字， 如SELECT FROM
    
    3.2 语法分析：根据词法分析结果，根据语法分析结果判断是否满足MYSQL语法。
        没问题就构建SQL语法树
        
4. 执行SQL
    SELECT执行阶段： prepare(预处理), optimize(优化), execute(执行)
    
    预处理：
        检查SQL语句中的表或字段是否存在
        将 *(通配符) 扩展为表上所有列
        
    优化器：
        确定SQL查询语句的执行方案，选择查询成本最小的执行计划
            
    执行器：
        执行器调用read_first_recode函数指针指向的函数，根据优化器选择的访问类型
            函数指针被指向InnoDB引擎 索引/全扫描 的接口，把条件交给存储引擎，让存储引擎定位符合条件的记录
            存储引擎取出一条记录，交给执行器判断，不是则跳过，是则发给客户
            
    回表：
        数据库在使用索引优化查询时，需要通过索引来查找数据行的指针，再根据这些指针去主表（数据表）中查找实际的行数据。
        涉及两次访问：
            1. 通过索引查找满足查询条件的记录，获取对应的数据指针
            2. 根据数据指针，从主表中读取完整的行数据。
            
        例子：现在执行以下查询
                SELECT email, address FROM users WHERE username = 'john_doe';
                假设 username 上有一个二级索引 (idx_username)。查询需要 email 和 address 两个列，这两个列不在索引 idx_username 中
            1. 使用索引 idx_username 查找 username = 'john_doe' 对应的记录指针。
            2. 通过记录指针 回到主表 users 中，获取 email 和 address 列的数据。
                这就是一次回表
                
    索引下推：
        减少二级索引在查询时的回表操作，提高查询效率。将Server层部分负责事情交给存储引擎层处理
        定位到满足二级索引的查询条件后，继续判断其他查询条件，条件不成立直接跳过该二级索引
			
## 2. MYSQL一行记录是怎么存储的			
MYSQL数据保存在磁盘中，存储行为是由存储引擎实现的。常用存储引擎比如InnoDB。
    
查看MYSQL数据库的文件存放在哪个目录
```
SHOW VARIABLES LIKE 'datadir';
```
    
假设在my_database的数据库中有一张my_table的表
则进入/var/lib/mysql/my_database中
- db.opt：存储当前数据库的默认字符集和字符校验规则
- my_table.frm :存储my_table的表结构，保存每个表的元数据信息，包含表结构定义
- my_table.ibd ：存储my_table的表数据
    
即：一张数据库表的数据是保存在 表名.ibd 的文件里，该文件也称为独占表空间文件
    
表空间
    由段(segment)、区(extent)、页(page)、行(row)组成。
    
### 页：
InnoDB的数据是按[页]为单位来读写的。当读取一条记录时，以页为单位整体读入内存。
- 默认页大小为16KB。
    页是InnoDB存储引擎磁盘管理的最小单元。数据库每次读写都是以16KB为单位。
        一次最少从磁盘中读取16K的内容到内存中，一次最少把内存中的16K内容刷新到磁盘中。
        
    B+树中每一层通过双向链表连接。
    在表中数据量很大时，为某个索引分配空间的时候不再按照页而是按照区为单位分配。
    每个区大小为1MB。对16KB的页来说，连续64个页被划为一个区，使得链表中相邻的页的物理地址也相邻，就能使用顺序I/O。
    
### 段：
一般分为数据段、索引段、回滚段等。
    
- 索引段：存放B+树的非叶子节点的区的集合；
- 数据段：存放B+树的叶子节点的区的集合；
- 回滚段：存放回滚数据的区的集合。
    
### 行：
InnoDB提供4种行格式，分别是Redundant、Compact、Dynamic和Compressed
    Redundant最老
    compact是紧凑的行格式
    从MYSQL5.7版本之后, 默认使用Dynamic

Compact
    一条完整记录分为[记录的额外信息]和[记录的真实数据]
    记录的额外信息包含：变长字段长度列表、NULL值列表、记录头信息
    
1. 变长字段长度列表
    变长字段长度列表里存储了该条数据中变长字段 各列的占用字节大小，逆序存储
    NULL不放在行格式中[记录的真实数据]部分，变长字段长度列表不保存值为NULL的变长字段的长度

为什么[变长字段长度列表]的信息逆序存放？
    因为记录头信息中指向下一个记录的指针，指向下一条记录的记录头信息和真实数据之间的位置。
    好处是向左读就是记录头信息，向右读就是真实数据。
    使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个CPU Cache Line中，提高CPU Cache命中率

2. NULL值列表
    Compact行格式把值为NULL的列存储到NULL值列表中
    如果存在允许NULL值的列，每个列对应一个二进制位，二进制按照列的顺序逆序排列
    二进制值为1，该列值为NULL
    二进制值为0，该列值不为NULL
    NULL值列表必须用整数个字节的位表示(1字节8位)。如果二进制位不足整数个，在高位补0

每个数据库表的行格式都有NULL值列表吗？
    不是，当字段都定义为NOT NULL，表里的行格式就不会有NULL值了。
    
NULL值列表固定1字节吗？
    不是，根据有多少允许NULL的列，按照字节倍数创建
    
3. 记录头信息
    delete_mask：标识数据是否被删除。执行detele删除记录，不会真正删除，只是delete_mask标记为1
    next_record：下一条记录的位置：记录与记录之间通过链表组织。
    record_type：当前记录的类型。0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录
    
记录真实数据部分 除了用户定义信息，还有三个隐藏字段：row_id, trx_id, roll_pointer

row_id: 
    如果建表时指定了主键或唯一约束列(该列上数据唯一,不能有重复值),就没有row_id。
        否则添加row_id。占用6字节
        
trx_id:
    事务id: 表示这个数据是由哪个事务生成的。必须，占用6字节。

roll_pointer:
    记录上一个版本的指针。必须，占用7个字节。
    
### varchar(n)中n最大取值？
MYSQL中规定除了TEXT、BLOBs这种大对象类型外，所有其他的列(不包含隐藏列和记录头信息)
    占用字节长度加起来不超过65535字节。

n代表最多存储的字符数量，注意不是字节。
    这取决于字符集：字符集代表着1个字符占多少个字节。比如Ascii 1字符1字节

总限制长度因为要包含变长字段长度列表和NULL值列表， 所以小于65535.
    如果变长字段允许存储的最大字节数小于等于255字节，用1字节表示 变长字段长度
    如果大于25字节，用2字节表示
    
### 行溢出后，MYSQL如何处理？
MYSQL 磁盘和内存交互的基本单位是页。而一页大小为16KB.
使用大对象如TEXT、BLOB可能存储更多数据，一页装不下导致[行溢出]
InnoDB在行溢出后自动将溢出数据放到溢出页(一般情况下在数据页)
真实数据用20字节存储指向溢出页的地址。

Compressed 和 Dynamic 采用完全的行溢出方式，原先存真实数据处只存储20字节指针指向溢出页。

## B+树：
### 主要特性：
- 是一种多路平衡搜索树，每个内部结点(非叶子节点)包含多个关键字，用来指导搜索路径。
- 所有数据都在叶子结点，内部结点只存储关键字用于索引和导航
- 叶子结点之间通过链表连接。

### 为什么选择B+树而非其他平衡树：
    1. 高度优化的磁盘存取：
        块存取优化:每个节点可以存储多个关键字和指针，与磁盘块的大小相匹配。
        例如：如果磁盘块大小为4KB, B+树节点(包括内部节点和叶子节点)可以设计为占满一个磁盘块，以最大化每次磁盘IO的数据量
        注意：是每个节点占用一个或多个磁盘块
    2. 减小树的高度：B+树通常比二叉平衡树(如AVL树、红黑树)低。
        这意味着查找数据时，需要的磁盘访问次数更少,提高查询效率
    3. 顺序访问优化：
        叶子节点通过链表连接，支持高效的顺序扫描。
    4. 内部节点作为导航
        内部节点不存储实际数据：使得内部节点更小，能存储更多的关键字和指针

### B+树的阶
对于阶为M的树
B树的阶：
    每个节点最多有M个子节点
    每个节点至少有(M/2)上取整个子节点，根节点不受限制
    
    每个节点最多存储M-1个键值
    每个节点至少存储(M/2)上取整-1个键值
    
B+树的阶：
    每个节点最多有M个子节点
    每个节点至少有(M/2)上取整个子节点，根节点不受限制
    
    每个叶子节点最多存储L个键值
    每个叶子节点至少存储(L/2)上取整个键值
    
    
### B+树和B树
    B+树只在叶子节点存储数据。B树的非叶子节点也存数据。
    由于内部节点(非叶子节点)不存储实际数据，每个节点可以存储更多的键值。键值本身通常比数据记录要小。
    所以B+树的单个节点的数据量更小，在相同磁盘I/O下, 能查询更多的节点。
    
    另外B+树的叶子节点采用的是双链表连接，使用MYSQL中常见的基于范围的顺序查找
    
### B+树和其他平衡树
1.二叉平衡树(如AVL树、红黑树)
    - 一个节点只包括一个关键字和两个指针，树的高度较高，磁盘访问次数较多
    - 范围查询效率低：范围查询需要频繁回溯路径，B+树可以顺序遍历叶子节点
    - 缓存效率低：	较高的树高度和较低的节点密度意味较多的内存页面需要被访问，降低缓存命中率。
    - 时间复杂度：	对于N个叶子节点的B+树，搜索复杂度为O(logdN)。其中d表示节点允许的最大子节点个数为d个。实际应用中，d值通常大于100。而二叉树的搜索复杂度为O(logN)

2. HASH
    - 不适合范围查询, hash在做等值查询的时候，搜索复杂度为O(1)
    - 处理哈希冲突需要额外的数据结构
    - 内部存储无序，无法直接支持有序访问

## 3. 索引
帮助存储引擎快速获取数据的数据结构

索引分类：  
- 按数据结构分：B+Tree 索引、 HASH索引、 Full-Text索引
- 按物理存储分：主键索引、二级索引
- 按字段特性分：主键索引、唯一索引、普通索引、前缀索引
- 按字段个数分：主键索引、联合索引
    
创建表时，根据不同场景选择不同的列作为索引：  
1. 有主键，使用主键作为主键索引的索引键
2. 没有主键，选择第一个不包含NULL值的唯一列作为聚簇索引的索引键
3. 都没有，生成自增的row_id作为主键索引的索引键

    其他索引都是二级索引。主键索引和二级索引默认使用 B+Tree 索引。
    主键索引的 B+Tree 的叶子节点存放的是实际数据
    二级索引的 B+Tree 的叶子节点存放的是主键值

    B+Tree是一种多叉树，叶子节点放数据，非叶子节点放索引。每个节点的数据按主键顺序存放。
    B+Tree相比B树和二叉树来说，最大优势在于查询效率很高，即使数据量很大，查询一个数据的磁盘I/O依然维持在3~4次

回表:
    假设根据二级索引来查找一条数据，流程是：
    根据二级索引找到对应叶子节点，获取主键值，再通过主键索引查找对应叶子节点：经历2个B+树的查询。
    
### 覆盖索引
当查找内容数据在叶子节点里有的话，就不用回表，这就是覆盖索引。

### 全文索引：
专门用于优化和支持对大规模文本数据进行搜索的索引类型。
    是一种特殊数据结构，存储文本数据中的词汇及其出现位置、频率，以支持高效的文本搜索操作。
步骤：
    1. 分词：将文本数据拆封为单个词汇
    2. 建立倒排索引：为每个词汇创建一个索引，记录该词汇出现的文档ID及位置
    3. 当用户发起搜索时，全文索引通过查找相关词汇的倒排列表，定位包含关键词的文档，并根据相关性进行排序。
    
现代存储系统通过压缩、建立前缀索引等方式来优化全文索引的搜索效率。(常用词汇也没那么多)

### 主键索引：PRIMARY KEY
主键索引就是建立在主键字段上的索引。
一张表最多一个主键索引，索引列的值不允许有空值。

主键字段：表中用于唯一标识每一行记录的一个或多个字段。
    主键保证了表中每一行的数据都是独一无二的，并且不能包含NULL值。
主键索引是数据库自动为主键字段创建的一种特殊索引。

### 聚簇索引：
将数据行按照索引键的顺序进行排序和存储。
    默认情况下，如果存在主键，将主键索引设为聚簇索引
    如果不存在主键，将基于其他唯一非空索引或系统生成的隐藏列(raw_id),此时聚簇索引与主键索引无关
    
隐藏列
    聚簇索引中含有两个隐藏列
        trx_id: 当一个事务对某条聚簇索引记录进行改动时，把该事务的事务id记录在trx_id隐藏列：注意是修改时，不是提交也不是启动时
        roll_pointer:每次对某条聚簇索引记录进行改动时，把旧版本记录写入undo日志中，roll_pointer指向旧版本记录

### 唯一索引：UNIQUE KEY
唯一索引建立在UNIQUE字段上，一张表可以有多个唯一索引。
    索引列的值唯一，但允许有空值。
    
### 普通索引
建立在普通字段上。

### 前缀索引：
对字符类型字段的前几个字符建立的索引。
可以建立在字段类型为char, varchar, bianry ,varbinary的列上。 其中*binary为二进制数据类型。
    
### 联合索引：
将多个字段组合成一个索引
CREATE INDEX index_1and2 ON table_(c1, c2);

联合索引的非叶子节点用两个字段的值作为B+树的Key值。
假设有两个字段A和B， 联合索引的查询逻辑是先按A比较，在A相同的情况下再按B比较。
因此，使用联合索引，存在[最左匹配原则]，即按最左优先的方式进行索引匹配。
所以，假设创建了一个(a,b,c)的联合索引，
可以匹配where a=1;
    但是不能匹配 b=2;
    
    另外，最左匹配原则下最左索引一定是有序的。对于无序字段就没办法进行索引查询。(只能依次扫描而不能通过索引减少查询量)
        
***利用索引的前提是索引里的Key是有序的***
		
联合索引范围查询
    并不是查询过程使用了联合索引查询，就代表联合索引中所有字段都用到了联合索引进行索引查询。
    这种情况发生在范围查询。最左匹配原则一直向右匹配到范围查询停止。
        举个例子：假设	a=1 的范围索引关键字下对应b=2, b=3, b=4。
                        a=2	的范围索引关键字下对应b=5, b=6。
        对于匹配a=1的情况，联合索引是可以依次联合索引的。
        但是对于范围查询比如a>0，所有符合条件的b就不是有序的，就不能索引了。

MYSQL中 BETWEEN包含边界值
    比如 WHERE a BETWEEN 2 AND 8 包含a=2和a=8
    
    SELECT * FROM t_user
		
## 4. 慢查询如何优化
1. 识别慢查询
    1.1 启动慢查询日志
    SET GLOBAL slow_query_log = 'ON'
2. 使用EXPLAIN语句分析查询
3. 优化索引
    创建单列索引、联合索引
    如果查询只涉及索引中的列，可以直接从索引中返回结果(覆盖索引),避免回表查询
4. 优化服务器配置
    调整InnoDB缓冲区大小为物理内存的60%-80%
	
## 5. B+树索引如何更新
1. 插入
    - 找到插入位置
    - 在叶子节点插入键值
    - 处理上溢(叶子节点已满(键值数量未达到最大容量))
        1. 叶子节点满时，将叶子节点分裂为两个节点，中间点(中位数)将键值分配到新旧两个叶子节点
        2. 保存分裂点的中键并插入到父节点的对应位置：这里分裂点通常是新的右叶子节点的第一个节点
        3. 更新叶子节点的链表指针
        4. 递归处理父节点已满的问题
2. 删除
    - 找到删除位置
    - 在叶子节点中删除键值，如果删除后叶子节点键值数量仍满足最小要求(通常m/2-1),则操作完成
    - 处理叶子节点下溢
        1. 尝试从兄弟节点借一个键，保持节点的最小键值数量
        2. 如果兄弟节点也无法借键，需要与兄弟节点合并

## 6. 锁机制
	类型：共享锁(S锁)和排他锁(X锁)
		S锁允许事务读取数据项，但不允许修改
		X锁允许事务读取和修改数据项，
	
		多个事务可以同时对同一数据加共享锁，从而允许同时读取该数据项
	
	兼容性：
		排他锁与共享锁不兼容
		当事务A对数据项D加了S锁，其他事务此时不能对数据项加X锁，直到所有共享锁被释放。
		
	注意：这里说的是排他锁期间不能加共享锁(来读写)，但是仍允许快照读对数据访问。
		快照读是基于MVCC的读取方式，意味着其他事务不能获取排他锁期间的最新版本数据，但是可以获取旧版本数据。

## 7. 事务(TRANSACTION)
事务是数据库系统中用于管理和操纵数据的一系列操作的集合。  
事务由MYSQL的引擎实现。
- 并非所有引擎支持事务，MYSQL原生的MYISAM引擎不支持事务，InnoDB支持事务。

### 实现事务遵守4个特性：  
1. 原子性
    一个事务中的所有操作，要么全部完成，要么全部不完成。事务在执行过程中发生错误，会回滚到事务开始前的状态。
2. 一致性
    事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
3. 隔离性
    数据库允许多个并发事务同时对其数据进行读写和修改的能力。
    隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致。
    因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务隔离。
4. 持久性
    事务处理结束后，对数据的修改是永久的。

### InnoDB如何保持这4个特性？
- 原子性->undo log(回滚日志)
- 持久性->redo log(重做日志)
- 隔离性->MVCC(多版本并发控制)或锁机制保证
- 一致性->通过原子性+持久性+隔离性保证

### 隔离性：
现象  
1. 脏读：
    一个事务B读到另一个未提交事务A修改过的数据。
    如果这时候A发生回滚，B读到的就是过期数据。
2. 不可重复读
    一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一致，就发生了不可重复读。
    比如事务A先读取数据，再处理逻辑，这时候B修改数据并提交，事务A再读取数据就发生了不可重复读。
3. 幻读
    在一个事务内多次查询某个符合查询条件的记录数量，如果前后两次查询不一致，就发生了幻读。
    和不可重复读原理类似，在读取记录数量前后另一个事务修改了数据。

### 事务的隔离级别：
以上三种现象的严重性 脏读>不可重复读>幻读
SQL标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率越低。
隔离级别由高到低：串行化>可重复读>读提交>读未提交

- 读未提交：	一个事务还没提交，它的变更就被其他事务看到
- 读提交：	一个事务提交后，它的变更才能被其他事务看到
- 可重复读：	一个事务执行过程中的数据，和这个事务启动时看到的数据是一致的。InnoDB引擎默认的隔离级别
- 串行化：	对记录加上读写锁，多个事务对这条记录进行读写时，如果发生读写冲突，后访问的事务必须等前事务执行完成，才能继续执行。

读未提交不能避免所有现象，读提交可避免脏读，读提交可避免不可重复读，可重复读可避免不可重复读，串行化可避免所有问题

InnoDB默认使用可重复读，通过以下方式避免幻读现象  
- 针对快照读，通过MVCC方式解决幻读
- 针对当前读，通过next-key lock(记录锁+间隙锁)方式解决幻读。
    
### 事务隔离级别的具体实现：
- 读未提交：	想读就读
- 读提交：	在每条语句执行前生成Read View(快照)
- 可重复读：	在启动事务时生成一个Read View
- 串行化：	加读写锁避免冲突访问

### 事务不同命令启动的时机：
    start/begin transaction :执行该命令后执行第一条语句
    start transaction with consistent snapshot: 马上启动事务

ReadView 在MVCC中如何工作？
    ReadView有4个字段
        creator_trx_id, m_ids, min_trx_id, max_trx_id
    
        creator_trx_id	:创建该Read View的事务的事务id
        m_ids			:当前数据库中[活跃事务]的事务id列表，活跃事务是启动但还未提交的事务
        min_trx_id		:m_ids的最小值
        max_trx_id		:创建Read View时当前数据库中应该给下一个事务的id值，也就是全局事务中最大的事务id值+1

    根据聚簇索引中的trx_id字段(上一个对当前行记录修改的事务的id)：
        1. 如果trx_id小于min_trx_id，这个版本记录在创建快照前已经提交的事务生成，对当前事务可见。
        2. 如果trx_id大于max_trx_id, 这个版本记录在当前事务启动后启动的事务生成，该版本记录对当前事务不可见
        3. 在min和max之间，如果trx_id在m_ids列表中，表示该事务依然活跃，对当前事务不可见
                            如果不在，该事务已提交，该版本记录对当前事务可见。
        如果该版本记录对当前事务不可见，当前事务会顺着聚簇索引中roll_pointer字段递归查找旧版本记录
        这种通过[版本链]来控制并发事务访问同一个记录时的行为叫MVCC(多版本并发控制)。

可重复读如何工作？
    在事务启动时生成一个快照，整个事务期间使用这个快照
读提交如何工作？
    在每次读取数据时，生成一个新的快照。
    
    区别在于可重复读隔离级别下，当前活跃事务指定的m_ids在整个事务期间不变
        而读提交在每次读取数据时，m_ids随其他活跃事务提交而变动，就存在读取到新版本数据的可能。
					
## 9. 快照读和当前读
### 快照读
快照读是基于MVCC(多版本并发控制)的读取方式。
    允许事务读取特定时间点的数据快照，而不会被其他并发事务的未提交或后续提交的更改干扰。
- 特性：
    事务在开始时获得一个数据快照，后续读取操作都基于这个快照。
    快照读通常不需要加锁，因此不会阻碍其他事务的读写，提高并发性。
- 实现机制：
    Undo logs:当事务对数据修改时，在undo logs中保留数据的前一个版本。
    Read View:事务在开始时创建一个Read View, 记录当前活跃事务的状态，确保读取的数据版本不受并发事务影响。
- 应用场景：
    普通Select,不带有任何锁定指令(即不使用For update或Lock in share mode)
    只读事务
### 当前读
读取最新事务的方式，直接读取当前数据库中最新提交的数据。这种读取方式可能涉及加锁，以确保读取数据的一致性。
- 特性：
    读取数据反映了当前数据库的最新状态，包括其他事务已提交的更改。
    通常会对读取数据加锁，防止并发事务的修改。
    由于需要加锁，当前读可能会导致等待，在高并发场景下影响性能。
- 实现机制：
    使用Select ... for update 对读取的行加上排他锁
    或 select ... lock in share mode 对读取的行加上共享锁
- 应用场景：
    事务更新前的检查：修改数据前确保数据的当前状态
    需要锁定数据的场景：如银行转账

## 10. update
	select ... from update
	读取并更新，会对查询结果集中的所有匹配行加上排他锁
	
	update ... set ...
	在执行更新时，对受影响的每一行加上排他锁
	
## 11. 锁
数据库锁分为两大类：
- 行锁：锁定特定的数据行
- 表锁：锁定整个数据表
    
### 记录锁：
- 当一个事务对某一行数据加上记录锁时，其他事务不能对该行数据执行修改操作，但可以读取数据。
- 记录锁可以是读锁或写锁	

### 间隙锁：
- 锁定两个记录之间的"间隙"区域的锁。主要用于防止幻读现象。
- 锁定已有记录和记录间的间隙。
- 确保在事务执行期间，其他事务无法在锁定范围内插入新的记录。
- 适用于执行范围查询，而不是精确匹配的查询。

死锁情况：
    使用记录锁和间隙锁可能导致死锁产生，尤其在高并发环境下。

### 两阶段锁(Two-Phase Locking, 2PL)
- 读锁(共享锁)：防止在并发读取的同时写入
- 写锁(排他锁)：不允许对给定资源进行读和写操作

- 2PL协议将事务分为两部分：
    - 扩展阶段(获取锁,并且不允许释放锁)
    - 收缩阶段(释放所有锁,并且无法进一步获取其他锁)