---
title: "C++"
date: 2025-08-25 23:00:00 +0800
categories: [C++]
tags: [标签1, 标签2]
---

在类中: 
> 方法=成员函数，属性=成员变量

## 面向对象(Object Oriented Programming, OOP)
C++三大特性：封装、继承、多态
(也有说法是四大特性，第四个特性是抽象)

### 封装
将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。
### 继承
从已有类中派生出新类，新类具有已有类的属性(成员变量)和方法(成员函数)。  
并且扩展或修改这些属性和方法。

#### 继承列表：
``` C++
class 派生类 : [访问控制] 基类1, [访问控制] 基类2, ... {
    // 成员变量和成员函数
};
```
在冒号后的就是继承列表

##### 菱形继承问题：
一个类通过多个路径继承自同一个基类时，形成类似菱形的继承结构。  
可能导致基类被多次继承，从而引发二义性和资源冗余问题。
- 二义性
假设出现菱形继承, B::A, C::A, 而D::B,C  
当创建D对象并访问A成员时，编译器无法确定通过哪一个A类子对象来访问

###### 菱形继承解决方案：虚拟继承
基类在继承层次结构中只存在一份实例，从而避免冗余和二义性问题
- 原理：
1. 共享基类实例：所有通过虚拟继承从同一个基类继承的路径，共享一个基类的实例
2. 基类子对象唯一性：在最终派生类中，基类只出现一次。
- 语法：
在继承时使用virtual关键字
``` C++
	class Derived : virtual public base {}
```
###### 虚拟继承对构造函数影响
使用虚拟继承情况下，构造最终派生类对象时，构造函数调用顺序如下：
1. 基类构造：
- 先 虚拟基类的构造函数：无论虚拟基类在继承列表中的位置如何，虚拟基类的构造函数总是最早被调用
- 后 非虚拟基类的构造函数  
如果有多个非虚拟基类，构造顺序取决于它们在继承列表中的声明顺序，而不是在类定义中的顺序
2. 派生类成员变量的构造
	按照在类中的声明先后顺序被构造
3. 派生类的构造函数

###### 虚拟继承对析构函数影响
与构造函数相反：
1. 派生类的析构函数
2. 非虚拟基类的析构函数
3. 虚拟基类的析构函数
	
- Q. 为什么先成员变量构造再构造函数？
在构造之前确保所有成员变量已正确初始化

- Q. 成员变量构造之后内存分配位置：
取决于对象本身的分配方式
- 当对象是局部变量，它及所有成员变量放在栈上
- 使用new创建的对象及其成员变量分配在堆上
- 全局或静态对象分配在数据段或静态存储区

### 多态
同一种操作作用于不同对象，可以有不同解释和实现。
- 静态多态：通过**函数重载**或****运算符重载**实现，编译时确定调用哪个函数
- 动态多态：又称函数重写，通过**虚函数**和**继承**实现，运行时根据对象的实际类型调用对应的函数。

#### 构造顺序：
创建一个派生类对象时,构造函数的调用顺序遵循以下规则：
1. 虚拟基类的构造
2. 非虚拟基类的构造
3. 成员函数的构造
4. 派生类自身的构造
这种顺序确保虚拟基类在整个继承树中只被构造一次，并且在其他基类和成员对象之前完成，从而避免多次构造同一基类的问题

1. 虚拟基类的构造
	[虚拟继承]用于解决多重继承中的菱形继承问题，确保虚拟基类在继承层次结构中只存在一个实例。
2. 非虚拟基类的构造
3. 类的成员对象
4. 最后执行派生类的构造函数体

### 抽象
从具体实例中提取共同的特征，形成抽象类或接口，以便代码的复用和扩展。

#### 抽象类
**抽象类**是指至少包含一个纯虚函数的类。抽象类不能被实例化，只能作为其他类的基类，作为定义接口和共性行为。 
抽象类不能实例化，通常作为其他类的基类，提供接口和部分实现。
``` C++
class Abstract{
public:
    virtual void ab() = 0;
};
```
    
#### 纯虚函数
在基类中声明但不提供实现的函数，子类必须重写(实现)这些函数。
子类不重写的话必须也是抽象类。
``` C++
class Shape{
public:
    virtual double area() const = 0;
    
    virtual void describe() const{
    cout<<"output"<<endl;
    }
}
```
			
## 1. C语言指针
指针是一个变量，其值为另一个变量的内存地址。  
通过指针，程序可以间接访问和操作内存中的数据。

### 指针用途：
- 动态内存分配：		运行时分配和释放内存
- 数组和字符串处理：	高效访问和操作数据元素
- 函数参数传递：		通过指针实现传值和传地址
- 数据结构实现：		如链表、树、图

### 指针声明：
指针的声明需要指定其所指向的数据类型，举例
``` C
int *p;      // p是一个指向int类型数据的指针
char *cptr;  // cptr是一个指向char类型数据的指针
```
使用&运算符获取变量的内存地址，举例
``` C
int a = 10;
int *p = &a;  // 用&运算符获取变量a的地址，并赋给指针p
```
使用*运算符访问指针指向的值
``` C
int a = 10;
int *p = &a;
printf("%d\n", *p);  // 输出a的值，即10
```

### 指针运算：
指针可以加减运算，但增减操作会根据指针类型大小进行偏移
``` C
int(*p)[3] //p是一个指向含有3个元素数组的指针
```
每次p+1，将移动到下一个含有3个整数数组的位置
    
C语言中[]操作符优先级高于*解引用  
即`*p[i]`会被解析为`*(p[i])`

#### 指针运算例子：
``` C
int nArr[2][2][3] = {
        { {1,2,3}, {4,5,6} },
        { {7,8,9}, {10,11,12} }
    };
```
nArr是一个含有2个元素的数组，`nArr + 1`指向第二个int[2][3]元素，即nArr[1]
`&nArr + 1`将地址向后移动了一个整个数组的大小, 
(int*) 将指针类型转换为指向 int 的指针，(int*)(&nArr + 1) 指向nArr 末尾后一个 int 位置的指针。


## 1.1 C和C++区别
1. 编程泛式
- C是过程式编程语言，强调通过函数和过程组织代码  
- C++支持过程式、OOP、泛型和函数式编程等多种编程范式
    C++通过引入面向对象编程，使得代码更具模块化和可重用性
> 什么是过程式编程语言: 以“过程”（Procedure）或“函数”（Function）为基本组织单位,程序从上到下依次执行。
2. 内存管理
- C使用malloc, calloc, realloc和free进行动态内存分配和释放
- C++更加灵活，使用new和delete，简化内存操作
    - 引入智能指针来自动管理内存，减少内存泄漏风险
    - 使用RAII(资源获取即初始化)，通过构造函数和析构函数自动管理资源
3. 标准库
- C提供标准C库
- C++提供标准模板库(STL)
4. 函数
- C仅支持函数，不支持成员函数(方法)
    - 支持函数指针
- C++类中可定义成员函数，支持方法的重载和多态
    - 允许通过虚函数实现运行时多态
    - 同名函数可重载
5. 异常处理
- C语言没有内置异常处理机制，通常依赖返回值、全局变量(如errno)
- C++支持try, catch, throw, 提供结构化的异常处理机制
    - 提供丰富的标准异常类，如std::exception, std::runtime_error等
6. 模板和泛型编程
- C语言不支持模板和泛型编程，可通过宏实现部分代码泛型化
- C++支持函数模板和类模板
    - 模板元编程：允许在编译时进行复杂的计算和类型操作
6. 命名空间
C++引入命名空间(namespace),可以将函数、类、变量组织在不同的命名空间中，避免命名冲突
7. 输入输出
- C使用标准I/O库，使用stdio.h中函数，依赖格式化字符串进行数据的输入输出
- C++使用输入输出流
    - 通过重载运算符实现类型安全的输入输出操作
    - 支持自定义输入输出
8. 兼容性
- C语言通常用于系统性编程，与底层硬件和汇编语言有良好兼容性
- C++向后兼容C，大部分C代码可以在C++中编译和运行
    - 可以调用C库，通过extern "C"实现名称修饰的兼容

### 1.2 标准I/O
- scanf:默认会读取直到遇到空白字符(空格、换行、制表符)为止的所有字符
``` C
scanf("%5s", a);
```
- gets:读取一行的输入，直到遇到换行符。因为不执行缓冲区大小的检查，容易导致缓冲区溢出，所以从C11开始被移除
- `fgets(buf, sizeof(buf), stdin)`:读取最多sizeof(a)-1个字符
- 以上都是C风格的字符串，所以都会往末尾添加'\0'
					
##  函数指针：
``` C++
//定义一个函数
void greet(){
	std::cout<<"Hello World"<<std::endl;
}

//定义一个函数指针，指向返回类型为void， 参数为空的函数。
void (*funcPtr)();

//将函数指针指向greet;
funcPtr = &greet;

//通过函数指针调用
funcPtr();

//将函数指针指向另一个函数
funcPtr = &greet2;
funcPtr();
```
	
## 指针函数
返回类型为指针的函数。即该函数执行后返回一个指针。  
用途：
1. 动态分配内存后返回指针
``` C++
	int *getNumber(){
		int *ptr = new int(42);
		return ptr;
	}
	// 返回int*类型的指针。
	
	int main(){
		int* numPtr = getNumer();
		std::cout<<*numPtr<<std::endl; //输出42
		
		delete numPtr;
		return 0;
	}
```
2. 返回指向特定类型的对象的指针
3. 提供对某些数据结构中元素的访问
	
## 关键字
### const
const关键字用于声明变量为"常量"，即该变量的值在初始化后不可更改。
不仅适用于基本数据类型，也适用于指针、引用、类成员等多种场景。

#### 1. 修饰变量
``` C++
const int MAX_SIZE = 100；
```
#### 2. const指针
- 2.1 常量指针(pointer to Const)(*在后)
	- 指针指向的数据不能通过这个指针修改
	- 可以改变常量指针指向其他地址
``` cpp
const int* ptr; 
// 或者 int const* ptr;
```
- 2.2 指针常量(*在前)
指针本身是常量，即指针的地址不能被修改，但可以通过它来修改地址里内容
``` cpp
int a = 5;
int b = 10;
int * const ptr = &a;
*ptr = 20; // 合法。 可以修改指向的数据
// ptr=&b; //不合法，指针常量的地址不能改变
```
- 2.3 指向常量的常量指针
指针本身(地址)和指向的内容都不能修改

#### 3. const函数应用
##### 3.1 作为参数
- 3.1.1 传值参数中的const
	- const修饰传值参数 对调用者没有影响，因为传值参数在函数内部就是副本，仅仅是防止在函数内部修改变量
- 3.1.2 传引用
	对引用或指针参数使用const，防止函数修改调用者的数据
##### 3.2 返回类型
- 函数返回类型可以被声明为const。对于按值返回的函数没意义，因为传回的是副本。
- 如果返回是引用或指针类型的，可能会导致篡改类内数据。使用const 修饰按引用或按指针传递的返回类型，可以避免修改原始数据。

#### 4. const类内使用
##### 4.1 const成员函数
特点：  
1. **不修改对象的状态**：函数在执行过程中不会修改对象的任何成员变量(除非成员变量被声明为可变)
2. **只能调用其他常成员函数**：在这个成员函数内部，只能调用其他被声明为const的成员函数
，确保不会通过间接调用修改对象状态。
3. 可以通过[常量对象]或[常量引用/指针]调用这个成员函数。
4. 非const对象也可以调用const成员函数
5. 基类和派生类中, const修饰必须一致，以确保多态性和正确性
6. 临时对象默认是const, 只能调用const成员函数
	
##### 4.2 const对象
在对象的声明前使用const关键字
在声明时被指定为const的对象。意味着对象一旦被创建，其状态(成员变量的值)不能被修改。  
对于类的对象，可以同样使用const
``` C++
class Point{
public:
	int x_, y_;
	Point(int x, int y): x_(x), y_(y){}
	void move(int dx, int dy){
		x_ += dx;
        y_ += dy;
	}
	int getx() const {return x_}; //这里const表示该成员函数不会修改对象的成员变量
	int gety() const {return y_};
};

//实例化对象
const Point p(1,2);
cout<<p.getx()<<endl;
```
- 特点：
	- 不可修改
	- 只能调用const 成员函数
##### 4.3 const成员变量
类的成员变量可以声明为const, 需要在初始化列表中进行初始化，且不可更改。  
初始化列表就是指构造函数中根据传入值初始化。

#### 5. const与类型转换
- **`const_cast`**
用于移除或添加对象的const属性，主要用于指针和引用  
滥用const_cast可能导致未定义行为
- **`static_cast`**
不会修改const属性
	
# 6. const变量和宏变量有什么区别
- **类型安全**
  - `const` 变量有明确类型，编译器会进行类型检查，确保类型安全。
  - 宏只是简单的文本替换，没有类型信息。

- **作用域**
  - `const` 遵循 C++ 作用域规则，可以定义在局部或全局范围，具有明确作用域。
  - 宏在定义后，直到文件结束或被 `#undef`，在整个预处理范围内有效，可能导致命名冲突。

- **编译器处理**
  - `const` 由编译器处理，具有类型信息和作用域，能进行优化，如内联替换。
  - 宏变量由预处理器处理，仅文本替换，不参与编译器的类型检查和优化。

- **调试**
  - 调试时 `const` 变量有明确的地址和值。
  - 宏在预处理后被替换，没有独立的实体。

### constexpr
constexpr是const exprssion的缩写，用于指示编译器某个值或表达式可以在编译期间求值。  
编译时就能确定值，可以提高程序运行效率，允许更多编译期优化。
#### constexpr变量
constexpr变量必须在定义时初始化，并且初始化表达式必须在编译时可求值。
#### constexpr函数
在编译时可求值的函数，用constexpr修饰返回值
c++11版本，函数体内仅包含一条return 语句。
c++14版本后可以包含多条语句，如条件判断、变量声明等。 
#### constexpr与类
##### constexpr构造函数
被constexpr修饰的构造函数，其所有成员必须是字面类型
> [字面类型]:可以在编译时计算的类型，比如int, double
> 字面类型包括：标量类型、引用类型、数组类型、满足条件的类或结构体
当声明一个对象为constexpr时，整个对象及其成员的初始化在编译时完成。
在constexpr构造函数中，只能执行那些在编译时求值的操作。
##### constexpr成员函数
函数必须声明为constexpr
函数体内所有操作必须在编译时可求值
##### constexpr静态成员变量
必须在类内声明为static constexpr
		
#### constexpr的规则和限制
1. 必须在定义时初始化
2. 初始化表达式必须是编译时常量
3. constexpr构造函数类的成员变量必须在编译时初始化，不允许有虚函数或虚继承。因为编译器无法确定具体调用哪个虚函数实现。
4. 类型限制：只有字面类型才能用constexpr修饰
	
### extern
用于声明变量或函数在其他文件中定义。  
主要用于实现[跨文件的变量和函数共享]，帮助编译器了解变量或函数的存在，而不必在当前文件重复定义。

#### 声明外部变量
一个变量在一个文件中定义后，如果需要在其他文件中使用该变量，就需要使用`extern`关键字声明。  
可以用于声明类的外部对象，注意是**对象**，步骤：  
1. 在一个源文件中(如main.cpp)定义类的对象
2. 在一个头文件中使用 `extern` 声明该对象
3. 在其他需要使用该对象的源文件中包含该头文件，从而访问同一对象

#### 声明外部函数
函数在一个文件中定义后，可以在其他文件中使用，无需再次定义，但可以通过函数原型进行声明。
这里说的外部函数通常是全局函数，即具有全局链接。  
使用static关键字声明的全局变量具有内部链接，仅在定义它的源文件可见，所以这类函数不适用于`extern`
#### 链接规范 `extern "C"`
用于指定使用C语言的编译方式。常用于c和c++的混合编程，避免名称修饰导致的链接错误。  
c++支持函数重载，相同的函数名称可以传入不同参数列表，通过[名称修饰]实现
然而c不支持函数重载，所以为了在c++中调用C或让C调用c++函数，使用extern "C" 避免名称修饰.

> [名称修饰]：是编译器在编译过程中对函数名、变量名等进行的一种转换。
> 转换的目的是为了支持某些语言特性，比如函数重载、类成员函数等。
> 名称修饰使得编译器在生成的目标代码中唯一地标识每个函数和变量，即使他们在源代码中有相同名字。
- 作用: 告诉c++编译器，将指定函数用C规则编译(不用名称修饰)
- 用法：在函数声明上面加一个extern "C",由于是函数申明所以一般放在头文件里。
#### 注意事项
1. 避免多重歧义：
使用extern可以防止多个文件中重复定义同一个变量或函数，但需要确保每个全局变量或函数在整个程序中只有一个定义。
2. 初始化外部变量
extern声明的变量不能初始化。初始化只能在变量定义时进行。
``` C++
extern int gVar =10; //这会编译错误。
```
3. 若在多个文件中使用extern声明但没有提供相应定义，会导致链接错误。
4. 局部变量
extern关键字用于声明全局变量或函数，不能用于局部变量。
5. 命名空间影响
C++中，`extern`声明也受限于命名空间。
			
### static
`static` 关键字用于控制变量和函数的生命周期、作用域及访问权限，涵盖全局变量、局部变量、函数以及类成员。
#### 1. 静态变量  
- 1.1 静态全局变量  
	- 在函数外部(文件作用域)中定义。
	- 静态存储期，在程序整个生命周期中存在
	- 具有**内部链接性**，即该变量只在定义它的源文件中访问，无法被其他源文件使用，有助于实现封装，防止命名冲突。  
- 1.2 静态局部变量  
	- 在函数或代码块内部使用。  
	- 静态存储期，变量在程序运行期间只初始化一次，多次函数调用期间保持其值。
	- 作用域仅限于定义它的函数内部。 

#### 2. 静态函数 
static关键字作用于函数, 分为全局静态函数和类的静态成员函数
- 2.1 全局静态函数
	- 内部链接，只能在定义他的源文件中调用，不能被其他源文件访问

#### 3. 类的静态成员
- 3.1 静态成员变量
	- 静态成员变量属于整个类。所有类的实例共享同一个静态成员变量。
	- 静态成员变量必须在**类外定义**，以分配存储空间。
	- 这里定义一般放在类定义(如A.cc)所在的文件里。注意不能在main()里初始化,main也是函数有局部作用域
	- 由于静态成员变量与类的所有实例共享，因此必须在一个确定的翻译单元中进行定义，以避免链接时出现重复定义或未定义错误。
	- 可以不显式初始化，编译器会分配默认值：内置类型如(int, char)置零，类类型调用对应默认构造函数
	- 常态静态成员变量(且是整型)可以在类定义内初始化。

- 3.2 静态成员函数
	- 类中静态函数属于整个类，而不是某个特定对象。
	- 可以在没有类实例的情况下被调用，通过`类名::函数名`
	- 静态成员函数只能访问静态成员变量和其他静态成员函数，不能访问类的非静态成员。

#### 4. 静态存储期
> **静态存储期**指变量在程序的整个生命周期存在。
使用`static`关键字声明的变量,无论作用域如何(全局、静态变量、类的静态成员)，都具有静态存储期。
- 变量在程序开始时分配内存，在程序结束时释放内存。

#### 5. 存储位置
- 静态变量（包括静态局部变量和静态成员变量）和全局变量都在数据段（data segment），而非栈区。

- Q:静态成员变量何时被分配到内存的数据段？
- A:在程序加载(编译->链接->加载)时被分配到内存的数据段
	- 全局静态成员变量在程序启动时被初始化, 并在整个程序运行期间存在。
	- 局部静态成员变量在程序第一次执行到定义所在代码时被初始化, 并在整个程序运行期间存在。

	具体来说：  	
	- 在编译阶段：编译器识别类中的静态成员变量，并为其分配内存地址。由于静态成员变量通常定义在对应.cpp文件中，编译器在该文件的符号表中为其分配一个全局符号
	- 在链接阶段：链接器将所有翻译单元中的符号解析并分配到最终可执行文件中
	- 在程序加载阶段：将可执行文件加载到内存中，分配数据段的空间存储静态成员变量

#### 5. 其他用法
- **匿名命名空间**
就是不带名字的namespace, 可以取代全局静态变量和全局静态函数的使用，有更好的灵活性和可读性

#### 6. 继承问题
- 静态成员变量属于类本身，可以被派生类继承，但只有一份存储空间
- 静态局部变量只在定义它的函数作用域内有效，不是类成员，不存在继承问题。
- 静态成员函数可以被继承，在访问权限允许情况下可以被调用。

#### 7. 静态方法不能是虚方法
	静态方法(静态成员函数)不依赖于对象实例，而虚方法需要通过对象实例调用。通过基类指针或引用调用虚方法时，会根据实际对象类型执行相应的重写方法。
		
#### 8. c++11新特性
C++11在语言标准中明确规定，局部静态变量的初始化是线程安全的。这意味着：
1. 单次初始化：	无论多少线程同时调用包含局部静态变量初始化的函数，变量只会初始化一次。
2. 同步机制：	编译器会自动处理必要的同步，确保变量完全初始化之前，其他线程无法访问该变量
3. 无数据竞争：	消除因多线程竞争导致的初始化数据竞争问题。

### noexcept
c++11引入，所修饰的函数在执行过程中不会抛出异常。这意味着catch不会捕获到异常
#### 常见用途
标记移动构造函数和移动赋值运算符为 `noexcept`，以便容器等标准库组件能够进行更高效的操作。

### virtual
用于声明虚函数的关键字。
- 虚函数允许在继承层级结构中实现动态绑定，即在运行时根据对象的实际类型调用相应的函数，而不是根据指针或引用的静态类型。
- 虚析构函数
	- 当使用基类指针删除子类对象时，如果基类的析构函数不是虚函数，可能导致资源泄漏。
	- 确保正确调用子类的析构函数
	- 资源泄漏的原因：如果基类的析构函数不是虚函数，会调用基类的析构函数。

- 虚函数表
	虚函数表是用来支持运行时多态的机制。当一个类声明了虚函数时，编译器为该类生成一个虚函数表。这个表包含指向该类所有虚函数的指针。
- 虚表指针
	每个对象中有一个指向虚函数表的指针，称为虚表指针

- 实现原理：
	- 虚表(vtable)是一个静态表格，存储了指向类的虚函数的指针。
	- 虚表指针(vptr)：每个对象包含一个隐藏的指针，指向该对象所属类的虚表。
		vptr通常在对象的内存布局中位于最前面。
- 工作机制：
	- 当对象被创建时，**构造函数**负责初始化vptr,让它指向所属类的虚表。
		- 对于继承关系，子类的构造函数会覆盖父类的vptr，指向子类的虚表。
	- 当通过基类指针或引用调用虚函数时，编译器生成代码，通过对象的vptr访问虚表，从虚表中找到相应的函数指针，并调用该函数
	- 在多继承中，每个基类都有自己的虚表。派生类的对象将包括多个vptr,每个指向不同基类的虚表。
- 实现细节:
	- 虚表通常保存在只读数据段中，防止被意外修改。
	- 每个对象的内存布局中自动插入一个vptr，指向类的虚表。
	- 当子类重写虚函数时，子类的虚表会包含指向子类实现的函数指针，覆盖父类的相关条目。

- 为什么构造函数不能是虚函数？
构造函数是用于对象初始化的，而虚函数依赖于虚函数表，虚函数表的建立是在对象构造过程中设置的。

### inline(内联)
内联是一种将函数或变量的实际代码嵌入到调用点的优化方法。
- 优点
	1. 消除函数调用的开销：避免执行跳转指令和堆栈操作
	2. 优化代码：允许编译器在内联后对代码进一步优化，如常量折叠
	3. 提高缓存性能：减少函数调用带来的指令跳转，有助于提高指令缓存的命中率
- 缺点：
	1. 代码膨胀：增加可执行文件的大小
	2. 编译器需要处理更多的代码替换，可能增加编译时间
- inline作用
	1. 建议编译器将函数内联,编译器根据自身优化策略决定是否内联
	2. 

- 完全内联：
	编译器将函数或变量的所有访问点都进行内联处理，确保生成的机器代码中不再存在任何间接访问或函数调用的痕迹

- 引用中的完全内联
	将引用转为对原始变量的直接操作，避免生成实际的指针操作
	
- c++17开始，可以使用inline在类内部进行静态成员变量初始化
	static inline A* instance = nullptr;

### friend
授予某个类或函数对另一个类的private和protected成员的访问权限

### decltype 
是 C++11 引入的一个关键字，用于查询表达式的类型
	define、typedef、inline
		define
			只是简单的字符串替换，没有类型检查
			在编译的预处理阶段起作用
			防止头文件重复引用
			不分配内存
		typedef
			用于创建类型的别名，提高代码的可读性和可维护性。
			有对应数据类型, 在编译时检查
			在编译、运行时起作用
		inline
			将内联函数编译完成后插入被调用的地方
			减少压栈、跳转和返回操作，减少函数调用开销
			是一类特殊函数，会进行类型检查
			编译器有可能拒绝inline请求
	
	const和define区别
		const定义常量，define定义宏
		const生效于编译阶段，define生效于预处理阶段
		const定义的常量存储在内存中，define不分配内存
		const定义常量有类型，define不带类型
		
	new 和 malloc
		new是c++运算符, malloc属于c标准库函数
		new分配内存并调用构造函数， malloc仅分配内存
		new 返回特定类型指针，malloc返回void*，需要显式类型转换
		new 分配失败时抛出std::bad_alloc异常, malloc返回NULL
		new 使用delete或delete[]释放内存，并自动调用析构函数, malloc使用free
		
			
const 和constexpr
	const用于声明一个变量为只读，即值在初始化后不能修改
	constexpr声明在编译时可以求值的常量表达式，在 需要编译时常量或优化 时使用
			
volatile
	与const绝对对立
	作用：确保本条指令不会因编译器优化而省略，保证对特殊地址的稳定访问

## 指针
### 什么是指针
- 指针是一个变量，用于存储另一个变量的地址。
- 换句话说：指针指向某个数据的内存位置。
- 所有指针的值的实际数据类型，都是一样的，是一个代表内存地址的长的十六进制数。
### NULL指针
- 在指针变量声明时，如果没有明确地址可以赋值，为指针变量赋一个NULL是好的编程习惯。
- 大多数操作系统不允许访问地址为0的内存，因为这是给操作系统保留的。
- 对于指针来说，指针的值为NULL代表它不指向任何东西。

### 指针的算术运算
指针是一个用数值表示的地址，可以对指针进行四种算术运算: ++, --, +, -
指针算术运算是根据指针类型和大小决定的。
如果是一个int* 类型的指针，每次++会移动4个字节，因为这代表指向下一个int的内存地址
	
#### 指针的比较
- 相等性比较：	检查两个指针是否指向相同位置
- 关系比较(<,>)：	确定一个指针是否指向的位置在另一个指针之前或之后。通常在指针指向同一个数组的元素时有意义。

#### 指针和数组
- C风格的数组(arr[]), 数组名会退化为指向数组第一个元素地址的指针。
``` C
int arr[] = {1,2,3};
int *p = arr;
```
但是对arr++来试图访问其他成员是错误的。(简单来说可以通过*arr来访问第一个元素的值，但是不能修改arr本身地址的值)
- c++风格的数组(array, vector)不会退化。
- 数组提供了成员函数data()来返回指向第一个元素的指针。
5. C++指针数组
让数组存储指向int或其他数据类型的指针。
``` C++
	int *ptr[MAX];
```
这里ptr是一个数组，由MAX个整数指针构成。ptr中每个元素，都是一个指向int值的指针。

6. 指向指针的指针(多级间接寻址)
比如：指向int类型指针的指针：
``` C++
int **var;
```
即：var里存了一个int类型指针的变量的地址

7. 传递指针给函数
定义一个变量，把它地址传递给函数，在函数内通过*修改其地址的值。
	
8. 指针资源的释放(delete)：
指针变量和指针所指对象的不同，指针变量存储的是内存地址。*ptr或ptr所指向对象是存储在该内存地址上的实际数据或对象。
- 当调用delete ptr，实际上是在释放ptr所指向对象的内存(将对应内存地址收回标记为可用)
- 所以delete ptr只释放了ptr所指向的内存，而不是ptr变量本身的内存。
- 删除后, ptr仍是一个合法的指针变量，但是现在指向一个已经释放的内存，即它现在是一个悬挂指针。
ptr可以被重新赋值，或者置空避免指针悬挂。
**注**：delete 可以安全地作用于空指针
	
9. 悬挂指针：
- 指针指向一个已被释放的内存地址
- 使用悬挂指针可能会访问到非法地址，导致错误
		
## 智能指针
智能指针是c++中一种封装原生指针的类模板。通过RAII(资源获取即初始化)机制，实现对动态分配内存的自动管理。

### 核心设计思想
1. 对象生命周期绑定:智能指针对象的析构函数自动释放所管理的内存，无需手动delete
2. 所有权定义：		通过类型系统(独占或共享)明确资源的所有权归属，避免内存泄漏或非法访问
	
### 常见智能指针
- `unique_ptr`: 独占所有权，同一时间仅允许一个指针管理资源
- `shared_ptr`: 共享所有权，通过引用计数管理资源生命周期
- `weak_ptr`:	弱引用，配合`shared_ptr`解决循环引用问题，不增加引用计数

### 核心作用：
1. 自动内存管理：当智能指针对象超出作用域时，析构函数自动调用`delete`或自定义删除器释放资源  
即使程序异常中断，智能指针仍能确保资源释放，避免传统指针因代码分支遗漏释放的问题
2. 防止悬空指针：
`shared_ptr`在引用计数归零后，自动将内部指针置为`nullptr`，避免访问已释放的内存区域。
3. 管理共享资源的所有权：
- `shared_ptr`允许多个指针共享同一资源，计数归零时自动释放
- `unique_ptr`确保资源仅被单一所有者控制，适用于需要严格独占的场景。
4. 解决循环引用问题
`weak_ptr`不增加引用计数
		
### unique_ptr
独享被管理对象指针所有权。  
包装一个原始指针，并负责其生命周期。当该对象被销毁时，在其析构函数中`delete`原始指针。
- 独享所有权：  
	- unique_ptr**始终是**关联的原始指针的唯一所有者，无法复制unique_ptr对象，只能移动。
	- 不能通过赋值的方式传递对象
	- 不能通过拷贝构造函数或拷贝赋值运算符创建unique_ptr对象的副本
	- 但是可以通过std::move转移资源所有权
		
### shared_ptr
共享所有权，多个shared_ptr可以共同拥有同一个资源
#### shared_ptr线程安全吗？
- 引用计数是线程安全的
- 指针所指向对象是不安全的，shared_ptr仅负责管理对象的生命周期，不负责对象本身的线程安全性。因此，如果多个线程同时访问或修改shared_ptr所指向的对象，需要额外的同步机制(如互斥锁)来确保线程安全
		
### weak_ptr
- 不影响引用计数、不能直接访问资源，需要通过lock()方法提升为shared_ptr才能使用
- 用于检查资源是否依然存在
					
## 空类
C++为空类自动实现的函数包括：
- 默认构造函数
- 默认析构函数
- 拷贝构造函数
- 移动构造函数
- 拷贝赋值运算符：将一个已有对象的内容赋值给另一个对象
- 移动赋值运算符
		
空类的大小至少为1字节。这是由C++标准决定的，确保每个对象有唯一的地址。
	
- **空基类优化**
当空类作为其他类的基类时，编译器可能会应用空基类优化，从而使继承类的大小不因空基类而增加。
比如  
``` C++
class parent: public Empty
	{
		int val;
	};
```
parent带有一个4字节的val，但parent类可能只占4字节。
		
## this指针
this指针是一个特殊的指针，在C++类的成员函数中使用。它指向调用该成员函数的对象的地址。
- 相当于在当前对象上调用成员变量或成员函数
- 它的引入主要是为了解决成员函数参数和成员变量同名的问题。
使用场景：  
1. 使用this指针明确指出要访问的是成员变量
2. 返回当前对象本身，使用return *this。
3. 在函数中访问当前对象的地址，使用this指针来获取。
	
特性：  
- 类型是 `类类型* const`, 即成员函数不能给this赋值
- this指针是成员函数第一个隐含的指针形参，一般情况下由编译器通过ecx寄存器自动传递
- 禁止在静态成员函数中调用：静态成员函数不属于任何对象。
- 允许链式调用：通过返回*this.

### void*
void*被称作空指针或通用指针，是一种特殊指针类型，用于指向任意类型的数据。
使用场景：  
1. 和C语言兼容
2. 存储任意类型的数据
3. 动态内存分配时，`void*`是`malloc`的返回值，需要将其转换为具体类型
4. 实现回调函数，作为上下文参数，传递任意类型的数据
	
## 锁(lock)
lock_guard和unique_lock
- lock_guard适用于简单的作用域锁定
- unique_lock更复杂一点，主要特点包括：
	- 支持手动锁定和解锁
	- 支持移动语义(所有权转移)
	- 常与条件变量一起使用

## 互斥量(mutex)
### `std::mutex`
- 仅支持独占锁（exclusive lock）。
- 不能共享，即同一时间只有一个线程持有锁。
- 适合简单的互斥访问场景。

### `std::shared_mutex`
c++标准库提供的一种同步原语，用于实现共享(读)和独占(写)访问控制。
- 支持共享锁（shared lock）和独占锁（exclusive lock）
- 允许多个线程同时持有共享锁（读操作），但独占锁（写操作）时排他访问。
- 适合读多写少的场景，提高并发性能。

### `std::recursive_mutex`
- 支持同一线程多次加锁（递归锁）。
- 适用于递归调用或函数内部多次加锁的场景。
- 但存在死锁风险，使用时需谨慎。

		
## 回调
回调指将一个函数作为参数传递给另一个函数，并在特定事件或操作完成后调用这个函数。回调函数分为同步回调和异步回调。
	
	
### 回调机制：
直接将类的成员函数传递给接受普通函数指针的接口会导致编译错误。
问题根源：
- 成员函数(非静态)的类型为：
	- void (A::*)()表示这是A类的一个成员函数指针
	- 调用时需要一个对象实例，即通过对象或指针来调用：如a.callback()或(a_ptr->*callback)()
	- 编译器会隐式传递一个隐藏的this指针给成员函数，用于访问对象的成员变量和其他成员函数
	
- 普通函数指针类型为：
	- void (*)()
	- 调用时不需要任何对象实例。

根本原因是使用this来传递成员函数，这个成员函数是代表某个对象的实例的。所以解决办法如：使用静态成员函数(不带实例)

### 成员函数和成员函数指针：
1.成员函数的调用
通过对象或指针，如a.func()或a_ptr->func()
2. 成员函数指针：
- 将成员函数作为参数传递或存储，这就需要使用成员函数指针。
- 成员函数指针的使用和声明。

### 如何解决：
1. 使用静态成员函数和上下文指针
	- 1.1	声明一个静态的当前类对象指针: static A* instance, 
		- 在构造函数中传递this指针给instance
		- 在静态成员函数中调用instance->callback_f();而后将该静态成员函数作为参数传入接口
		- 不适用于多实例场景：这里类对象指针是静态的，只能初始化一次
	- 1.2 改进办法是使用上下文指针：修改function类型为 void(*function)(void*)
		- 在调用静态成员函数时将this传入void*接口并类型转换为A*作为instance，然后调用instance->callback_f();
2. 使用function和lambda表达式
	
## auto
用于在[局部变量]的声明中自动推导类型。
- 不能用于[类的成员变量声明]
	- 理由是：编译器在类定义时需要确切知道每个成员变量的类型，以便正确分配内存和布局类结构

- Q:如果想在类中使用某种可调用对象（比如比较函数 cmp），但不能用 auto 声明成员变量时，怎么办
- A:解决方案包括：
	1. 使用std::function作为cmp类型
	2. 使用具体函数对象
	3. 声明cmp为静态成员函数
	4. 在成员函数内部使用auto
			
##  宏&类型别名
- 类型别名用于为现有类型创建一个新的名称, 可以使用`typedef`或`using`来定义类型别名
- 宏是c/c++预处理器的功能，用于在编译前执行文本替换

主要区别： 
1. 作用域
	- 类型别名受[作用域规则]的约束
	- 宏是全局的，在整个编译单元生效，除非被#undef
2. 类型检查
	- 编译器对类型别名进行类型检查
3. 命名空间
	- 类型别名可以在命名空间中定义，使其只在特定的命名空间中生效
4. 模板
	- 类型别名支持模板和类型推断

## 同步和异步区别
- 同步：任务按照顺序依次执行，一个任务完成后才能进行下一个任务
- 异步：任务可以并行执行，调用者在发起操作后无需等待其完成，可以立即执行后续代码，任务操作完成后通过回调函数、信号量等通知调用者。
	
## 引用
为变量创建别名

### 底层实现：
在c++中使用引用时，编译器通常会将引用转换为指针，并在生成的汇编代码中使用该指针。
	- 这种转换过程对程序员来说是隐式的，不需要显式地管理。
- 编译器优化：
	- 完全内联：	对于简单的引用，编译器可能会将引用完全内联，避免任何指针操作
	- 寄存器使用：如果引用生命周期很短，编译器可能将其值存储在寄存器中，而不是内存地址，从而提高效率
	- 消除冗余：	引用在函数中只使用一次，编译器可以直接将其替换为原始变量

- 类型：可以分为左值引用和右值引用
	- 左值引用 T& 	绑定到左值，可以修改引用的对象
	- 右值引用 T&&	绑定到右值，通常用于实现移动语义和完美转发

### 多重引用和引用折叠  
C++不支持引用的引用，多个引用会被折叠为一个引用
	
### 引用和指针  
	由于引用底层通常被实现为指针，引用和指针性能差别不大。
### 引用的限制  
	- 必须初始化：	在声明时必须初始化，无法延迟绑定
	- 不可重新绑定：	一但被绑定到某个对象，不能再绑定到其他对象
	- 不能为nullptr：	必须始终绑定到有效的对象，不能像指针一样指向nullptr
		
### 取地址符
c++中，函数名在大多数情况下会隐式转换为指向该函数的指针。 
也就是说，在需要函数指针的时候，可以直接使用函数名，而不需要显式加上取地址符`&`

何时必须用`&`
1. 重载函数
	存在函数重载，编译器无法确定指的是哪个函数
2. 处理类的非静态成员函数。

### 指针和引用的区别
- 指针存放某个对象的地址
- 引用就是变量的别名

1. 定义和声明：
``` C++
	int x = 10;
	int *ptr = &x;
	int &ref = x;
```
2. 使用和操作：
指针：
``` C++
	int value = *ptr; // 获取指针指向的值
	int address = &x; // 获取变量的地址
```
引用：
``` C++
	int newValue = ref; // 获取引用的值
```
3. 空值和空引用
	- 指针可以为空表示不指向任何地址
	- 引用必须在声明时初始化，不能在后续改变引用绑定的对象
4. 可变性
	- 可以改变指针指向的内存地址
	- 引用被初始化后一直引用同一个对象

## __标识符
这些标识符主要由编译器和标准库实现,用户禁止定义。常见的有：
1. 预定义宏
``` C++
__LINE__ 	//当前代码行的行号		多用于日志记录和调试信息
__FILE__	//当前源文件的文件名	
__cplusplus	//当前使用的c++标准版本
__func__	//当前函数的名称，是标准化的
__FUNCTION__ //最初作为扩展由编译器(如GCC)提供，不是C++标准的一部分，效果与__func__相同
```

2. 编译器特定的关键字和扩展
``` C++
__builtin_expect	//(GCC, Clang支持)用于提供优化信息，帮助编译器进行分支预测
					//如if(__builtin_expect(EXP,N)) 意思是EXP等于N的可能性很大
__builtin_popcount	//一个整数在二进制中1的位数
					//注:c++20引入<bit>头文件提供std::popcount效果相同，这有助于跨平台开发
__attribute__		//基本语法：`__attribute__((attribute_list))`，跟在[函数声明]后
```
`__attribute__`常见的属性(attribute_list)包括：
- deprecated：标记函数、变量或类型过时，编译器在使用时会生成警告
- noreturn:	指示函数不会返回，用于优化和生成更好的警告信息
- always_inline, noinline：是否总是被内联或禁止内联
- packed：	不对结构体成员进行对齐
- aligned:	指定变量或类型的对齐方式

## 数据对齐
将数据的起始地址调整为某种特定的字节边界  
例如一个int类型通常4字节，意味着int类型变量的地址应该是4的倍数
- 为什么需要？
	- 许多数据访问对齐的数据时效率更高
	- 一致的对齐方式有助于简化内存管理

- 结构体中的对齐
	1. 成员变量的对齐
	需要满足成员变量的起始地址满足其自身的数据对齐要求
	2. 结构体整体对齐
	结构体整体大小需要是其内部成员最大对齐要求的倍数。

- 基本数据类型(如char, int, double)也有自然对齐要求
- 类也有对齐要求，因为C++类和结构体的**唯一区别**是默认的访问权限

- 联合体对齐
	所有联合体共用一块内存，对齐要求是所有成员中最大对齐要求的那个。
		
## 递归优化
递归如何优化
1. 尾递归优化
	- 尾递归指的是递归调用发生在函数的末尾，即在返回递归调用的结果之前。
	- 尾递归优化的核心思想是将递归调用转为迭代，避免每次递归调用都创建新的栈帧。
		具体来说：编译器重用当前函数的栈帧来承载下一次递归调用的参数，而不额外分配新的栈空间。

> 栈帧：也称为活动记录，是程序在执行函数调用时，在调用栈中分配的一块内存区域。
> 每当一个函数被调用，系统为其分配一个新的栈帧，存储该函数执行所需的各种信息。函数执行完毕，对应的栈帧被销毁。
> 一个典型的栈帧包括：
> - 返回地址：函数调用后程序需要返回的位置
> - 参数，局部变量
> - 保存的寄存器状态：在函数调用前，一些寄存器的值需要保存，以便函数返回后恢复到调用前的状态
> - 帧指针：指向当前栈帧的基地址，用于(通过偏移量)访问栈帧中的变量和参数
2. 递归展开
	- 将递归调用的函数体直接嵌入到调用点，减少函数调用开销
	- 由于递归深度不确定和代码膨胀问题，实际编译器对递归展开支持有限
3. 消除不必要的递归调用
某些递归函数中存在多余的条件判断和无法到达的递归分支，可以通过编译器优化。
例如：  
- 常量优化： 	如果递归函数的某些参数是常量，编译器预先计算结果，减少递归次数
- 死代码消除：移除永远不会执行的递归分支
4. 转换递归为迭代
手动减少函数调用开销，提高执行效率

## 内存分配
### 概述
内存通常被划分为以下几个区域：
- 代码区：存储程序的机器指令
- 数据区：
	- 静态数据区：存储全局变量和静态变量
	- 常量区：	存储字符串字面量和常量数据
	> 字符串字面量是指在源代码中直接表示字符串数据的固定文本。是由一对双引号(")包围的字符序列。
	> 原始字符串字面量是C++11引入的一种字符串表示方式：std::string str = R"(内容)"，内容可以包含特殊字符或多行文本而无需转义序列
- 堆区：用于动态内存分配
- 栈区：用于存储局部变量、函数参数和返回地址

### 内存分配类型
C++中内存分配主要分为静态分配和动态分配
- 静态分配：
	- 静态分配的内存由编译器在编译时分配，生命周期贯穿程序的整个运行期间。
	- 包括全局变量、静态变量和常量。
- 动态分配：
	- 动态分配的内存在运行时由程序员手动管理，主要通过堆进行分配和释放。

### 动态内存管理机制
1. new和delete
	- new：在堆上分配内存，并自动调用构造函数初始化对象
	- delete:释放内存，并调用析构函数销毁对象
2. malloc和free
	- C风格的动态内存管理方法，定义在<cstdlib>中。
	- malloc用于分配内存，返回void*指针
	- free用于释放内存。
	- 需要手动进行类型转换和初始化
3. new[]和delete[]
	动态分配和释放数组
4. 其他概念
	1. 智能指针：	自动管理动态分配的内存
	2. 内存池：		预先分配一大块内存并在其中管理，减少频繁new/delete带来的开销
		适用于需要频繁分配和释放小块内存的场景。
5. 使用现代c++特性
	- 智能指针用于管理内存；
	- RAII容器如vector,string代替裸指针,自动管理资源
	- 移动语义通过移动构造函数和移动赋值运算符，减少不必要的内存拷贝，提高性能。

### malloc
为该进程的[虚拟地址空间]分配一块连续的内存区域，并将其映射到物理内存或磁盘交换空间，返回这块虚拟内存区域的指针，供程序调用。

#### 物理内存的映射
	虽然malloc分配的是虚拟内存，但操作系统通过内存管理单元将虚拟地址映射到物理地址。这种映射是动态的，表现为：
	1. 按需分页：只有当程序实际访问某页虚拟内存时，操作系统才会将其映射到一个物理页框
	2. 页面置换：当物理内存不足时，操作系统可能将不活跃的页面移至磁盘交换空间，腾出物理内存给活跃的页面。
	
#### malloc的底层实现
1. malloc检查当前堆区域是否有足够的可用内存
2. 如果堆空间不足，使用brk/sbrk扩展堆
	- 方法是：调整进程的数据段，增加程序断点
	- brk:设置数据段的末端，即程序断点的位置。
	- sbrk:相对于当前程序断点，增加或减少数据段的大小。
3. 当malloc请求的内存超过一定阈值(128kB),使用mmap来分配内存。
	- 这有助于减少堆的内存碎片，提高大块内存分配的效率。
	- 独立分配：通过mmap分配的内存块不会纳入堆的管理范围，而是独立存储，便于单独释放和管理。
	
#### mmap的底层实现
mmap是一个系统调用，用于将文件或设备映射到进程的虚拟地址空间，或分配匿名内存区域。当mmap被调用时，用户空间的内核会陷入内核模式，执行相应系统调用。
``` C++
void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
```
参数验证->内存区域分配->页面表更新->返回映射地址	

支持多种类型的内存映射
1. 文件映射
将文件内容直接映射到进程的虚拟地址空间，实现高效文件读写
2. 匿名内存映射
分配不与任何文件关联的内存区域，常用于线程栈、共享内存等
3. 设备映射
映射设备内存到用户空间，以便直接的设备访问。
			
- 内存保护和权限
	通过prot参数控制映射区域的访问权限
- 页面对齐
	要求映射地址和长度是页面大小的倍数
	
### 类的定义与内存地址
- 编译阶段：
	- 由编译器解析类的定义,包括成员变量，成员函数，继承关系等。  
		这一阶段决定了类的内存布局：即每个成员变量在对象中的位置和大小
	- 使用类的类型信息进行类型检查、函数重载解析、模板实例化等
	- 类本身不占用运行时内存
		只有当创建类的实例时，才会在内存中分配具体的空间
- 运行阶段：
	- 当程序运行并创建类的对象时(无论栈上、堆上还是全局/静态存储区),才会分配具体内存地址给这些对象的实例
	- 对象的内存地址在运行时动态分配的，取决于对象的创建方式和程序的内存分配策略

## 如何让函数在main()函数之前被调用？
1.使用全局对象的构造函数
	- 可以通过定义一个全局(静态)对象，在其构造函数中调用所需的函数。
	- 由于全局对象的构造函数在main()函数执行之前被调用，可以确保函数提前执行。
2. 静态初始化块
	- C++11引入的静态初始化机制
	
40.5 主定理
	用于分析分治算法的时间复杂度	
		可以直接从递归关系中推导出算法的渐进时间复杂度

43. sizeof和strlen
	strlen不带'\0'
	
	TODO：
	vector[i]=4的底层实现/push的底层实现
	迭代器实现归并排序
	华为1，3题
	输入M,n
	第一题：问最小的组合实现覆盖
	
	第三题：IP
		要求IP组尽可能多，相同IP组要IP包含的尽可能小，最后要小IP
		
			sort自定义排序，如果相同返回的是什么
	
	手搓socket
	
	http2, 3
	
	数组，实现归并
	
	http和https区别
	对称和非对称加密
	为什么https用对称，非对称，区别？
	
	进程间通信方式
	有名管道和匿名管道区别
	文件映射
	文件映射的优势，为什么非用不可
	虚拟内存多大？
	调度算法
	分页的优势
	
	Hash函数
	频繁发生冲突怎么处理？
	扩容后发生了什么？数组全部搬移吗？那你原来除留余法不是没解决频繁冲突问题吗？
	
	虚函数
	虚函数表和虚表指针

    序列和反序列化：
	本项目采用protobuf。
	功能是将类似于结构体的消息序列化为二进制数据。
	方法：protobuf提供的SerializeToString
	
在分布式系统下，RPC调用是一个高并发场景：有很多客户端和服务端建立TCP连接，发送服务调用请求。
	
动态代理？
	RPC服务端对外提供可调用方法: LoginResonse UserServiceRpc::Login(LoginRequest)
		接收入参对象LoginRequest并返回对象 LoginResponse
	在.proto文件中注册，使用protoc编译该文件，得到一组.cc和.h文件。这组文件可以和c++程序对接，
		利用protobuf提供的方法来封装要传输的消息结构体
		
服务发现
	客户端获取服务对象方法提供者地址信息的过程，称为服务发现。
	服务发现机制提供两个功能：
		1. 服务注册：服务提供方在提供服务前把自己的服务对象注册到注册中心上，
			注册中心把这个服务提供者的地址信息和提供的服务对象名和方法名保存下来。
		2. 服务订阅：在服务调用方 启动时，去注册中心找自己需要的服务对象对应的服务提供者的地址信息
			缓存到本地，为远程调用做储备。
	本项目使用zookeeper实现服务发现功能。
	
Wathcher机制来更新注册中心

项目流程?
	在user.proto中注册->调用protoc生成user.cc和user.h
	其中提供的Service虚类 包括UserServiceRpc和UserServiceRpc_stub类
		继承至UserService类做业务层实现。
		
	main()
	先框架初始化
	
	#define EXIT_FAILURE 1
	exit() 函数用于终止程序的执行并向操作系统返回一个退出状态码。
	通常有两种退出状态码：
		EXIT_SUCCESS：表示程序成功执行并正常退出，通常值为 0
		EXIT_FAILURE：表示程序执行失败，通常值为 1 或其他非零值
	
	getopt的用法：
	int getopt(argc, argv, "i:")
	i为命令行选项，如'i', 'f'
		返回值：正确获取到返回当前处理的选项字符，如'i'
				如果没有更多可解析字符，返回-1
	
std::unique_ptr
	C++11 引入的智能指针，用于管理动态分配的内存或资源
	std::unique_ptr<T, Deleter> ptr;
	这里T类型是FILE*, 所以unique_ptr被销毁时调用fclose关闭文件就行，不需要delete。
	
	char buf[1024]
	while(fgets(buf, sizeof(buf),pf.get())!=nullptr){
		string read_buf
	}
	
substr()用法
	string substr (size_t pos = 0, size_t len = npos) const;
	
NotifyService()
	定义结构体ServiceInfo保存服务信息
			成员:	Service* service
					unordered_map method_map
	定义mp service_map保存
	从google::protobuf::Service()->GetDescriptor()中获取服务信息：method()和name()
		打印并存至method_map中。
	将服务名和ServiceInfo再存到service_map中
	
atexit()
	int atexit(void (*func)(void));
		C标准库中的一个函数，用于注册程序退出时需要调用的清理函数。
		注册的函数将在程序正常退出时被调用，
		无论是通过 exit() 退出，还是通过程序的 main() 函数结束时退出。
		
this指针
	this指针指向当前对象的实例，
	在非静态成员函数中可用
	
	
protobuf, service->GetDescriptor
	获取的是在service.proto中注册的服务和方法
	服务为UserServiceRpc, 方法为Login, Register, 原定义如下：
		service UserServiceRpc{
		rpc Login(LoginRequest) returns(LoginResponse);
		rpc Register(RegisterRequest) returns(RegisterResponse);
		}

构造拷贝函数(copy operator)
	Myclass (const Myclass &other){}
重载赋值函数(copy assignment operator)
	Myclass& operator=(const Myclass &other)
	
=delete特性
	用来明确禁止某个函数的调用
	
strerror_r
	int strerror_r(int errnum, char *buf, size_t n);
	参数：
		-errnum: 	错误代码
		-buf；		用户提供的存储错误描述的缓存
		-n:			缓存的大小
	
. 和 -> 
	都用于访问对象的成员
	-有一个对象的实例（变量）时，可以使用点运算符 . 来访问其成员
	-当你有一个指向对象的指针时，需要使用箭头运算符 -> 来访问该对象的成员
			
数据类型
	short int long, long long
		short至少16位
		int至少和short一样长
		long至少32位，且至少和int 一样长
		long long至少64位，且至少和long 一样长
	
		8位bit=1字节
		
		unsigned：无符号，不存负数，存负数空间全拿来存正数
	
前置++和后置++的内部实现
	前置++直接修改并返回变量
	后置++创建一个临时拷贝，修改原变量后返回临时拷贝
	
atomic
	原子变量, 确保在多线程环境中线程安全执行
	Q: a++ int a=b；这两条语句是原子的吗？
	A: 不是，从编译器角度说，需要先将变量a对应的内存值搬运到某寄存器中，
		然后对该寄存器的值增1或改动，最后搬回内存。在这期间线程可能会改变
		
分布式系统：就是说多个计算机或节点协同完成任务。

## 1. 函数定义
### 定义在头文件会怎么样？
- 优点：	
1. 易于代码复用，可以方便多个源文件(.cpp)包含并使用这些函数
2. 内联优化：将小型函数定义在头文件，编译器有更多机会进行内联优化
    所以内联函数(使用inline修饰)通常在头文件定义  
- 缺点：	
1. 多重定义：一个函数定义在头文件，而该头文件被多个源文件包含，在链接阶段会出现"重定义"错误  
因为每个包含该头文件的源文件都生成了一个函数实例，编译器无法确定哪个版本
- 解决办法：
    - 使用inline关键字：  
        告诉编译器允许在多个翻译单元中存在该函数的定义，从而避免重定义错误  
        同时,编译器可能会将该函数进行内联展开，提升执行效率

### 模板函数应该定义在哪里？
模板函数的实现通常定义在头文件。因为模板在编译时进行实例化，编译器需要在使用模板时看到完整定义，以便根据类型生成相应代码。
		
7. 三字符组
	用于表示另一个字符的三个字符序列，又称三字符序列。总是以两个问号开头
	从 c++10开始默认不再自动替换三字符组。

8. 基本的数据类型
	bool, char, int, float, double, void
	
	修饰符
	signed(有符号，默认)
	unsigned
	short
	long 
	const 
	volatile 	变量可能被意外修改，禁止编译器优化
	mutable 	类成员可以在const对象中修改

## 访问控制
C++ 中类成员（变量和函数）的访问权限由三个关键字控制：
- private
- protected
- public

| 访问权限  | 类内访问 | 派生类访问 | 类外访问（对象访问） | 说明                         |
|-----------|----------|------------|---------------------|------------------------------|
| `private` | 可访问   | 不可访问   | 不可访问            | 仅限于本类内部使用            |
| `protected` | 可访问 | 可访问     | 不可访问            | 本类和派生类可访问，外部不可访问 |
| `public`  | 可访问   | 可访问     | 可访问              | 对所有代码开放                |

### private
只能在本类成员函数内部访问, 常用来隐藏实现细节，保护数据安全

### protected
可以被本类和派生类访问, 常用于希望派生类访问但不想暴露给外部的成员

### public
对所有代码开放访问, 常用于接口函数和需要外部访问的数据

### 默认设置
- 类（class）成员默认是 private
- 结构体（struct）成员默认是 public

#### 访问权限与继承方式权限变化

| 基类成员访问权限 | `public` 继承中派生类访问权限 | `protected` 继承中派生类访问权限 | `private` 继承中派生类访问权限 |
|------------------|-------------------------------|---------------------------------|-------------------------------|
| `public`         | `public`                      | `protected`                     | `private`                     |
| `protected`      | `protected`                   | `protected`                     | `private`                     |
| `private`        | 不可访问                     | 不可访问                       | 不可访问                     |

### 补充
- 友元（friend）：友元函数或友元类可以访问类的所有成员（包括 private 和 protected）。
- 访问控制是编译时机制，不影响内存布局。