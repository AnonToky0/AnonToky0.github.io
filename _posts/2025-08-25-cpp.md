---
title: "C++"
date: 2025-08-25 23:00:00 +0800
categories: [C++]
tags: [C++]
---

在类中: 
> 方法=成员函数，属性=成员变量


## 1. C语言指针
指针是一个变量，其值为另一个变量的内存地址。  
通过指针，程序可以间接访问和操作内存中的数据。

### 指针用途：
- 动态内存分配：		运行时分配和释放内存
- 数组和字符串处理：	高效访问和操作数据元素
- 函数参数传递：		通过指针实现传值和传地址
- 数据结构实现：		如链表、树、图

### 指针声明：
指针的声明需要指定其所指向的数据类型，举例
``` C
int *p;      // p是一个指向int类型数据的指针
char *cptr;  // cptr是一个指向char类型数据的指针
```
使用&运算符获取变量的内存地址，举例
``` C
int a = 10;
int *p = &a;  // 用&运算符获取变量a的地址，并赋给指针p
```
使用*运算符访问指针指向的值
``` C
int a = 10;
int *p = &a;
printf("%d\n", *p);  // 输出a的值，即10
```

### 指针运算：
指针可以加减运算，但增减操作会根据指针类型大小进行偏移
``` C
int(*p)[3] //p是一个指向含有3个元素数组的指针
```
每次p+1，将移动到下一个含有3个整数数组的位置
    
C语言中[]操作符优先级高于*解引用  
即`*p[i]`会被解析为`*(p[i])`

#### 指针运算例子：
``` C
int nArr[2][2][3] = {
        { {1,2,3}, {4,5,6} },
        { {7,8,9}, {10,11,12} }
    };
```
nArr是一个含有2个元素的数组，`nArr + 1`指向第二个int[2][3]元素，即nArr[1]
`&nArr + 1`将地址向后移动了一个整个数组的大小, 
(int*) 将指针类型转换为指向 int 的指针，(int*)(&nArr + 1) 指向nArr 末尾后一个 int 位置的指针。


## 1.1 C和C++区别
1. 编程泛式
- C是过程式编程语言，强调通过函数和过程组织代码  
- C++支持过程式、OOP、泛型和函数式编程等多种编程范式
    C++通过引入面向对象编程，使得代码更具模块化和可重用性
> 什么是过程式编程语言: 以“过程”（Procedure）或“函数”（Function）为基本组织单位,程序从上到下依次执行。
2. 内存管理
- C使用malloc, calloc, realloc和free进行动态内存分配和释放
- C++更加灵活，使用new和delete，简化内存操作
    - 引入智能指针来自动管理内存，减少内存泄漏风险
    - 使用RAII(资源获取即初始化)，通过构造函数和析构函数自动管理资源
3. 标准库
- C提供标准C库
- C++提供标准模板库(STL)
4. 函数
- C仅支持函数，不支持成员函数(方法)
    - 支持函数指针
- C++类中可定义成员函数，支持方法的重载和多态
    - 允许通过虚函数实现运行时多态
    - 同名函数可重载
5. 异常处理
- C语言没有内置异常处理机制，通常依赖返回值、全局变量(如errno)
- C++支持try, catch, throw, 提供结构化的异常处理机制
    - 提供丰富的标准异常类，如std::exception, std::runtime_error等
6. 模板和泛型编程
- C语言不支持模板和泛型编程，可通过宏实现部分代码泛型化
- C++支持函数模板和类模板
    - 模板元编程：允许在编译时进行复杂的计算和类型操作
6. 命名空间
C++引入命名空间(namespace),可以将函数、类、变量组织在不同的命名空间中，避免命名冲突
7. 输入输出
- C使用标准I/O库，使用stdio.h中函数，依赖格式化字符串进行数据的输入输出
- C++使用输入输出流
    - 通过重载运算符实现类型安全的输入输出操作
    - 支持自定义输入输出
8. 兼容性
- C语言通常用于系统性编程，与底层硬件和汇编语言有良好兼容性
- C++向后兼容C，大部分C代码可以在C++中编译和运行
    - 可以调用C库，通过extern "C"实现名称修饰的兼容

### 1.2 标准I/O
- scanf:默认会读取直到遇到空白字符(空格、换行、制表符)为止的所有字符
``` C
scanf("%5s", a);
```
- gets:读取一行的输入，直到遇到换行符。因为不执行缓冲区大小的检查，容易导致缓冲区溢出，所以从C11开始被移除
- `fgets(buf, sizeof(buf), stdin)`:读取最多sizeof(a)-1个字符
- 以上都是C风格的字符串，所以都会往末尾添加'\0'

## 函数指针和指针函数区别
##  函数指针(Pointer to Function)
``` C++
//定义一个函数
void greet(){
	std::cout<<"Hello World"<<std::endl;
}

//定义一个函数指针，指向返回类型为void， 参数为空的函数。
void (*funcPtr)();

//将函数指针指向greet;
funcPtr = &greet;

//通过函数指针调用
funcPtr();

//将函数指针指向另一个函数
funcPtr = &greet2;
funcPtr();
```
	
## 指针函数 (Function Returning Pointer)
返回类型为指针的函数。即该函数执行后返回一个指针。  
用途：
1. 动态分配内存后返回指针
``` C++
	int *getNumber(){
		int *ptr = new int(42);
		return ptr;
	}
	// 返回int*类型的指针。
	
	int main(){
		int* numPtr = getNumer();
		std::cout<<*numPtr<<std::endl; //输出42
		
		delete numPtr;
		return 0;
	}
```
2. 返回指向特定类型的对象的指针
3. 提供对某些数据结构中元素的访问

## 指针
### 什么是指针
- 指针是一个变量，用于存储另一个变量的地址。
- 换句话说：指针指向某个数据的内存位置。
- 所有指针的值的实际数据类型，都是一样的，是一个代表内存地址的长的十六进制数。
### NULL指针
- 在指针变量声明时，如果没有明确地址可以赋值，为指针变量赋一个NULL是好的编程习惯。
- 大多数操作系统不允许访问地址为0的内存，因为这是给操作系统保留的。
- 对于指针来说，指针的值为NULL代表它不指向任何东西。

### 指针的算术运算
指针是一个用数值表示的地址，可以对指针进行四种算术运算: ++, --, +, -
指针算术运算是根据指针类型和大小决定的。
如果是一个int* 类型的指针，每次++会移动4个字节，因为这代表指向下一个int的内存地址
	
#### 指针的比较
- 相等性比较：	检查两个指针是否指向相同位置
- 关系比较(<,>)：	确定一个指针是否指向的位置在另一个指针之前或之后。通常在指针指向同一个数组的元素时有意义。

#### 指针和数组
- C风格的数组(arr[]), 数组名会退化为指向数组第一个元素地址的指针。
``` C
int arr[] = {1,2,3};
int *p = arr;
```
但是对arr++来试图访问其他成员是错误的。(简单来说可以通过*arr来访问第一个元素的值，但是不能修改arr本身地址的值)
- c++风格的数组(array, vector)不会退化。
- 数组提供了成员函数data()来返回指向第一个元素的指针。
5. C++指针数组
让数组存储指向int或其他数据类型的指针。
``` C++
	int *ptr[MAX];
```
这里ptr是一个数组，由MAX个整数指针构成。ptr中每个元素，都是一个指向int值的指针。

6. 指向指针的指针(多级间接寻址)
比如：指向int类型指针的指针：
``` C++
int **var;
```
即：var里存了一个int类型指针的变量的地址

7. 传递指针给函数
定义一个变量，把它地址传递给函数，在函数内通过*修改其地址的值。
	
8. 指针资源的释放(delete)：
指针变量和指针所指对象的不同，指针变量存储的是内存地址。*ptr或ptr所指向对象是存储在该内存地址上的实际数据或对象。
- 当调用delete ptr，实际上是在释放ptr所指向对象的内存(将对应内存地址收回标记为可用)
- 所以delete ptr只释放了ptr所指向的内存，而不是ptr变量本身的内存。
- 删除后, ptr仍是一个合法的指针变量，但是现在指向一个已经释放的内存，即它现在是一个悬挂指针。
ptr可以被重新赋值，或者置空避免指针悬挂。
**注**：delete 可以安全地作用于空指针

	
9. 悬挂指针：
- 指针指向一个已被释放的内存地址
- 使用悬挂指针可能会访问到非法地址，导致错误

### 双重释放(Double Free)
程序中同一块动态分配的内存被释放(delete 或 free)了两次或多次, 导致程序行为异常，通常表现为崩溃、内存错误或安全漏洞。  
- 如果一个指针指向一块动态分配的内存，程序调用 delete 释放了这块内存后，这个指针变成了悬空指针（指向已经释放的内存）。
- 如果程序再次对这个悬空指针调用 delete，就会发生双重释放。
#### 如何避免？
- 深拷贝：确保每个对象拥有独立的资源，析构时释放自己独立的内存。
- 智能指针：使用 std::unique_ptr 或 std::shared_ptr 自动管理资源，避免手动调用 delete。
- 置空指针：释放指针后将其设为 nullptr，避免悬空指针误用。
- 遵循三法则/五法则，正确实现拷贝构造函数、赋值运算符和析构函数。
		
## 智能指针
智能指针是c++中一种封装原生指针的类模板。通过RAII(资源获取即初始化)机制，实现对动态分配内存的自动管理。

### 核心设计思想
1. 对象生命周期绑定:智能指针对象的析构函数自动释放所管理的内存，无需手动delete
2. 所有权定义：		通过类型系统(独占或共享)明确资源的所有权归属，避免内存泄漏或非法访问

### 常见智能指针
- `unique_ptr`: 独占所有权，同一时间仅允许一个指针管理资源
- `shared_ptr`: 共享所有权，通过引用计数管理资源生命周期
- `weak_ptr`:	弱引用，配合`shared_ptr`解决循环引用问题，不增加引用计数

### 核心作用：
1. 自动内存管理：当智能指针对象超出作用域时，析构函数自动调用`delete`或自定义删除器释放资源  
即使程序异常中断，智能指针仍能确保资源释放，避免传统指针因代码分支遗漏释放的问题
2. 防止悬空指针：
`shared_ptr`在引用计数归零后，自动将内部指针置为`nullptr`，避免访问已释放的内存区域。
3. 管理共享资源的所有权：
- `shared_ptr`允许多个指针共享同一资源，计数归零时自动释放
- `unique_ptr`确保资源仅被单一所有者控制，适用于需要严格独占的场景。
4. 解决循环引用问题
`weak_ptr`不增加引用计数
		
### unique_ptr
独享被管理对象指针所有权。  
包装一个原始指针，并负责其生命周期。当该对象被销毁时，在其析构函数中`delete`原始指针。
- 独享所有权：  
	- unique_ptr**始终是**关联的原始指针的唯一所有者，无法复制unique_ptr对象，只能移动。
	- 不能通过赋值的方式传递对象
	- 不能通过拷贝构造函数或拷贝赋值运算符创建unique_ptr对象的副本
	- 但是可以通过std::move转移资源所有权
		
### shared_ptr
共享所有权，多个shared_ptr可以共同拥有同一个资源
#### shared_ptr线程安全吗？
- 引用计数是线程安全的
- 指针所指向对象是不安全的，shared_ptr仅负责管理对象的生命周期，不负责对象本身的线程安全性。因此，如果多个线程同时访问或修改shared_ptr所指向的对象，需要额外的同步机制(如互斥锁)来确保线程安全
		
### weak_ptr
- 不影响引用计数、不能直接访问资源，需要通过lock()方法提升为shared_ptr才能使用
- 用于检查资源是否依然存在

## this指针
this指针是一个特殊的指针，在C++类的成员函数中使用。它指向调用该成员函数的对象的地址。
- 相当于在当前对象上调用成员变量或成员函数
- 它的引入主要是为了解决成员函数参数和成员变量同名的问题。
使用场景：  
1. 使用this指针明确指出要访问的是成员变量
2. 返回当前对象本身，使用return *this。
3. 在函数中访问当前对象的地址，使用this指针来获取。
	
特性：  
- 类型是 `类类型* const`, 即成员函数不能给this赋值
- this指针是成员函数第一个隐含的指针形参，一般情况下由编译器通过ecx寄存器自动传递
- 禁止在静态成员函数中调用：静态成员函数不属于任何对象。
- 允许链式调用：通过返回*this.

### void*
void*被称作空指针或通用指针，是一种特殊指针类型，用于指向任意类型的数据。
使用场景：  
1. 和C语言兼容
2. 存储任意类型的数据
3. 动态内存分配时，`void*`是`malloc`的返回值，需要将其转换为具体类型
4. 实现回调函数，作为上下文参数，传递任意类型的数据
	
## 锁(lock)
lock_guard和unique_lock
- lock_guard适用于简单的作用域锁定
- unique_lock更复杂一点

| 特性               | `std::lock_guard`        | `std::unique_lock`            |
|--------------------|--------------------------|-------------------------------|
| 加锁时机           | 构造时立即加锁           | 支持延迟加锁、尝试加锁等       |
| 解锁时机           | 析构时自动解锁           | 析构时自动解锁                 |
| 支持手动解锁       | 不支持                   | 支持                          |
| 支持锁所有权转移   | 不支持                   | 支持移动构造和赋值            |
| 支持条件变量等待   | 不支持  | 支持（`std::condition_variable::wait`需要） |
| 适用场景           | 简单加锁场景             | 复杂锁管理、条件变量、锁转移等 |

### unique_lock
`std::unique_lock`是 C++11 标准库 <mutex> 头文件中提供的一个通用的互斥量管理类模板，用于管理对 `std::mutex` 或其他互斥量类型的独占访问。  
它的设计基于 RAII（资源获取即初始化） 原则，构造时加锁，析构时自动解锁。

#### 基本接口和用法

``` cpp 
template <class Mutex>
class unique_lock {
public:
    // 构造函数
    explicit unique_lock(Mutex& m);              // 构造时加锁
    unique_lock(Mutex& m, std::defer_lock_t);    // 构造时不加锁，延迟锁定
    unique_lock(Mutex& m, std::try_to_lock_t);   // 构造时尝试加锁，失败不阻塞
    unique_lock(Mutex& m, std::adopt_lock_t);    // 构造时假设已加锁，不加锁

    // 移动构造和移动赋值（不支持拷贝）
    unique_lock(unique_lock&& u);
    unique_lock& operator=(unique_lock&& u);

    ~unique_lock();  // 析构时解锁（如果持有锁）

    // 操作锁
    void lock();     // 加锁（阻塞）
    bool try_lock(); // 尝试加锁，返回是否成功
    void unlock();   // 解锁

    // 查询状态
    bool owns_lock() const noexcept;  // 是否持有锁
    Mutex* mutex() const noexcept;    // 返回关联的mutex指针
};
```

#### 作用范围

``` cpp
std::mutex mtx;
{
    std::unique_lock<std::mutex> lock(mtx); // 构造时加锁
    // 这里持有锁，安全访问共享资源
} // 离开作用域，lock析构，自动解锁
```

## 互斥量(mutex)
### `std::mutex`
- 仅支持独占锁（exclusive lock）。
- 不能共享，即同一时间只有一个线程持有锁。
- 适合简单的互斥访问场景。

### `std::shared_mutex`
c++标准库提供的一种同步原语，用于实现共享(读)和独占(写)访问控制。
- 支持共享锁（shared lock）和独占锁（exclusive lock）
- 允许多个线程同时持有共享锁（读操作），但独占锁（写操作）时排他访问。
- 适合读多写少的场景，提高并发性能。

### `std::recursive_mutex`
- 支持同一线程多次加锁（递归锁）。
- 适用于递归调用或函数内部多次加锁的场景。
- 但存在死锁风险，使用时需谨慎。

		
## 回调
回调指将一个函数作为参数传递给另一个函数，并在特定事件或操作完成后调用这个函数。回调函数分为同步回调和异步回调。
	
	
### 回调机制：
直接将类的成员函数传递给接受普通函数指针的接口会导致编译错误。
问题根源：
- 成员函数(非静态)的类型为：
	- void (A::*)()表示这是A类的一个成员函数指针
	- 调用时需要一个对象实例，即通过对象或指针来调用：如a.callback()或(a_ptr->*callback)()
	- 编译器会隐式传递一个隐藏的this指针给成员函数，用于访问对象的成员变量和其他成员函数
	
- 普通函数指针类型为：
	- void (*)()
	- 调用时不需要任何对象实例。

根本原因是使用this来传递成员函数，这个成员函数是代表某个对象的实例的。所以解决办法如：使用静态成员函数(不带实例)

### 成员函数和成员函数指针：
1.成员函数的调用
通过对象或指针，如a.func()或a_ptr->func()
2. 成员函数指针：
- 将成员函数作为参数传递或存储，这就需要使用成员函数指针。
- 成员函数指针的使用和声明。

### 如何解决：
1. 使用静态成员函数和上下文指针
	- 1.1	声明一个静态的当前类对象指针: static A* instance, 
		- 在构造函数中传递this指针给instance
		- 在静态成员函数中调用instance->callback_f();而后将该静态成员函数作为参数传入接口
		- 不适用于多实例场景：这里类对象指针是静态的，只能初始化一次
	- 1.2 改进办法是使用上下文指针：修改function类型为 void(*function)(void*)
		- 在调用静态成员函数时将this传入void*接口并类型转换为A*作为instance，然后调用instance->callback_f();
2. 使用function和lambda表达式
	
## auto
用于在[局部变量]的声明中自动推导类型。
- 不能用于[类的成员变量声明]
	- 理由是：编译器在类定义时需要确切知道每个成员变量的类型，以便正确分配内存和布局类结构

- Q:如果想在类中使用某种可调用对象（比如比较函数 cmp），但不能用 auto 声明成员变量时，怎么办
- A:解决方案包括：
	1. 使用std::function作为cmp类型
	2. 使用具体函数对象
	3. 声明cmp为静态成员函数
	4. 在成员函数内部使用auto
			
##  宏&类型别名
- 类型别名用于为现有类型创建一个新的名称, 可以使用`typedef`或`using`来定义类型别名
- 宏是c/c++预处理器的功能，用于在编译前执行文本替换

主要区别： 
1. 作用域
	- 类型别名受[作用域规则]的约束
	- 宏是全局的，在整个编译单元生效，除非被#undef
2. 类型检查
	- 编译器对类型别名进行类型检查
3. 命名空间
	- 类型别名可以在命名空间中定义，使其只在特定的命名空间中生效
4. 模板
	- 类型别名支持模板和类型推断

## 同步和异步区别
- 同步：任务按照顺序依次执行，一个任务完成后才能进行下一个任务
- 异步：任务可以并行执行，调用者在发起操作后无需等待其完成，可以立即执行后续代码，任务操作完成后通过回调函数、信号量等通知调用者。
	
## 引用
为变量创建别名

### 底层实现：
在c++中使用引用时，编译器通常会将引用转换为指针，并在生成的汇编代码中使用该指针。
	- 这种转换过程对程序员来说是隐式的，不需要显式地管理。
- 编译器优化：
	- 完全内联：	对于简单的引用，编译器可能会将引用完全内联，避免任何指针操作
	- 寄存器使用：如果引用生命周期很短，编译器可能将其值存储在寄存器中，而不是内存地址，从而提高效率
	- 消除冗余：	引用在函数中只使用一次，编译器可以直接将其替换为原始变量

- 类型：可以分为左值引用和右值引用
	- 左值引用 T& 	绑定到左值，可以修改引用的对象
	- 右值引用 T&&	绑定到右值，通常用于实现移动语义和完美转发

### 多重引用和引用折叠  
C++不支持引用的引用，多个引用会被折叠为一个引用
	
### 引用和指针  
	由于引用底层通常被实现为指针，引用和指针性能差别不大。
### 引用的限制  
	- 必须初始化：	在声明时必须初始化，无法延迟绑定
	- 不可重新绑定：	一但被绑定到某个对象，不能再绑定到其他对象
	- 不能为nullptr：	必须始终绑定到有效的对象，不能像指针一样指向nullptr
		
### 取地址符
c++中，函数名在大多数情况下会隐式转换为指向该函数的指针。 
也就是说，在需要函数指针的时候，可以直接使用函数名，而不需要显式加上取地址符`&`

何时必须用`&`
1. 重载函数
	存在函数重载，编译器无法确定指的是哪个函数
2. 处理类的非静态成员函数。

### 指针和引用的区别
- 指针存放某个对象的地址
- 引用就是变量的别名

1. 定义和声明：
``` C++
	int x = 10;
	int *ptr = &x;
	int &ref = x;
```
2. 使用和操作：
指针：
``` C++
	int value = *ptr; // 获取指针指向的值
	int address = &x; // 获取变量的地址
```
引用：
``` C++
	int newValue = ref; // 获取引用的值
```
3. 空值和空引用
	- 指针可以为空表示不指向任何地址
	- 引用必须在声明时初始化，不能在后续改变引用绑定的对象
4. 可变性
	- 可以改变指针指向的内存地址
	- 引用被初始化后一直引用同一个对象

## __标识符
这些标识符主要由编译器和标准库实现,用户禁止定义。常见的有：
1. 预定义宏
``` C++
__LINE__ 	//当前代码行的行号		多用于日志记录和调试信息
__FILE__	//当前源文件的文件名	
__cplusplus	//当前使用的c++标准版本
__func__	//当前函数的名称，是标准化的
__FUNCTION__ //最初作为扩展由编译器(如GCC)提供，不是C++标准的一部分，效果与__func__相同
```

2. 编译器特定的关键字和扩展
``` C++
__builtin_expect	//(GCC, Clang支持)用于提供优化信息，帮助编译器进行分支预测
					//如if(__builtin_expect(EXP,N)) 意思是EXP等于N的可能性很大
__builtin_popcount	//一个整数在二进制中1的位数
					//注:c++20引入<bit>头文件提供std::popcount效果相同，这有助于跨平台开发
__attribute__		//基本语法：`__attribute__((attribute_list))`，跟在[函数声明]后
```
`__attribute__`常见的属性(attribute_list)包括：
- deprecated：标记函数、变量或类型过时，编译器在使用时会生成警告
- noreturn:	指示函数不会返回，用于优化和生成更好的警告信息
- always_inline, noinline：是否总是被内联或禁止内联
- packed：	不对结构体成员进行对齐
- aligned:	指定变量或类型的对齐方式

## 数据对齐
将数据的起始地址调整为某种特定的字节边界  
例如一个int类型通常4字节，意味着int类型变量的地址应该是4的倍数
- 为什么需要？
	- 许多数据访问对齐的数据时效率更高
	- 一致的对齐方式有助于简化内存管理

- 结构体中的对齐
	1. 成员变量的对齐
	需要满足成员变量的起始地址满足其自身的数据对齐要求
	2. 结构体整体对齐
	结构体整体大小需要是其内部成员最大对齐要求的倍数。

- 基本数据类型(如char, int, double)也有自然对齐要求
- 类也有对齐要求，因为C++类和结构体的**唯一区别**是默认的访问权限

- 联合体对齐
	所有联合体共用一块内存，对齐要求是所有成员中最大对齐要求的那个。
		
## 递归优化
递归如何优化
1. 尾递归优化
	- 尾递归指的是递归调用发生在函数的末尾，即在返回递归调用的结果之前。
	- 尾递归优化的核心思想是将递归调用转为迭代，避免每次递归调用都创建新的栈帧。
		具体来说：编译器重用当前函数的栈帧来承载下一次递归调用的参数，而不额外分配新的栈空间。

> 栈帧：也称为活动记录，是程序在执行函数调用时，在调用栈中分配的一块内存区域。
> 每当一个函数被调用，系统为其分配一个新的栈帧，存储该函数执行所需的各种信息。函数执行完毕，对应的栈帧被销毁。
> 一个典型的栈帧包括：
> - 返回地址：函数调用后程序需要返回的位置
> - 参数，局部变量
> - 保存的寄存器状态：在函数调用前，一些寄存器的值需要保存，以便函数返回后恢复到调用前的状态
> - 帧指针：指向当前栈帧的基地址，用于(通过偏移量)访问栈帧中的变量和参数
2. 递归展开
	- 将递归调用的函数体直接嵌入到调用点，减少函数调用开销
	- 由于递归深度不确定和代码膨胀问题，实际编译器对递归展开支持有限
3. 消除不必要的递归调用
某些递归函数中存在多余的条件判断和无法到达的递归分支，可以通过编译器优化。
例如：  
- 常量优化： 	如果递归函数的某些参数是常量，编译器预先计算结果，减少递归次数
- 死代码消除：移除永远不会执行的递归分支
4. 转换递归为迭代
手动减少函数调用开销，提高执行效率

## 内存分配
### 概述
内存通常被划分为以下几个区域：
- 代码区：存储程序的机器指令
- 数据区：
	- 静态数据区：存储全局变量和静态变量
	- 常量区：	存储字符串字面量和常量数据
	> 字符串字面量是指在源代码中直接表示字符串数据的固定文本。是由一对双引号(")包围的字符序列。
	> 原始字符串字面量是C++11引入的一种字符串表示方式：std::string str = R"(内容)"，内容可以包含特殊字符或多行文本而无需转义序列
- 堆区：用于动态内存分配
- 栈区：用于存储局部变量、函数参数和返回地址

### 内存分配类型
C++中内存分配主要分为静态分配和动态分配
- 静态分配：
	- 静态分配的内存由编译器在编译时分配，生命周期贯穿程序的整个运行期间。
	- 包括全局变量、静态变量和常量。
- 动态分配：
	- 动态分配的内存在运行时由程序员手动管理，主要通过堆进行分配和释放。

### 动态内存管理机制
1. new和delete
	- new：在堆上分配内存，并自动调用构造函数初始化对象
	- delete:释放内存，并调用析构函数销毁对象
**注意** 用new 动态分配的内存一定是在堆上。
2. malloc和free
	- C风格的动态内存管理方法，定义在<cstdlib>中。
	- malloc用于分配内存，返回void*指针
	- free用于释放内存。
	- 需要手动进行类型转换和初始化
3. new[]和delete[]
	动态分配和释放数组
4. 其他概念
	1. 智能指针：	自动管理动态分配的内存
	2. 内存池：		预先分配一大块内存并在其中管理，减少频繁new/delete带来的开销
		适用于需要频繁分配和释放小块内存的场景。
5. 使用现代c++特性
	- 智能指针用于管理内存；
	- RAII容器如vector,string代替裸指针,自动管理资源
	- 移动语义通过移动构造函数和移动赋值运算符，减少不必要的内存拷贝，提高性能。

### malloc
为该进程的[虚拟地址空间]分配一块连续的内存区域，并将其映射到物理内存或磁盘交换空间，返回这块虚拟内存区域的指针，供程序调用。

#### 物理内存的映射
	虽然malloc分配的是虚拟内存，但操作系统通过内存管理单元将虚拟地址映射到物理地址。这种映射是动态的，表现为：
	1. 按需分页：只有当程序实际访问某页虚拟内存时，操作系统才会将其映射到一个物理页框
	2. 页面置换：当物理内存不足时，操作系统可能将不活跃的页面移至磁盘交换空间，腾出物理内存给活跃的页面。
	
#### malloc的底层实现
1. malloc检查当前堆区域是否有足够的可用内存
2. 如果堆空间不足，使用brk/sbrk扩展堆
	- 方法是：调整进程的数据段，增加程序断点
	- brk:设置数据段的末端，即程序断点的位置。
	- sbrk:相对于当前程序断点，增加或减少数据段的大小。
3. 当malloc请求的内存超过一定阈值(128kB),使用mmap来分配内存。
	- 这有助于减少堆的内存碎片，提高大块内存分配的效率。
	- 独立分配：通过mmap分配的内存块不会纳入堆的管理范围，而是独立存储，便于单独释放和管理。
	
#### mmap的底层实现
mmap是一个系统调用，用于将文件或设备映射到进程的虚拟地址空间，或分配匿名内存区域。当mmap被调用时，用户空间的内核会陷入内核模式，执行相应系统调用。
``` C++
void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
```
参数验证->内存区域分配->页面表更新->返回映射地址	

支持多种类型的内存映射
1. 文件映射
将文件内容直接映射到进程的虚拟地址空间，实现高效文件读写
2. 匿名内存映射
分配不与任何文件关联的内存区域，常用于线程栈、共享内存等
3. 设备映射
映射设备内存到用户空间，以便直接的设备访问。
			
- 内存保护和权限
	通过prot参数控制映射区域的访问权限
- 页面对齐
	要求映射地址和长度是页面大小的倍数
	
### 类的定义与内存地址
- 编译阶段：
	- 由编译器解析类的定义,包括成员变量，成员函数，继承关系等。  
		这一阶段决定了类的内存布局：即每个成员变量在对象中的位置和大小
	- 使用类的类型信息进行类型检查、函数重载解析、模板实例化等
	- 类本身不占用运行时内存
		只有当创建类的实例时，才会在内存中分配具体的空间
- 运行阶段：
	- 当程序运行并创建类的对象时(无论栈上、堆上还是全局/静态存储区),才会分配具体内存地址给这些对象的实例
	- 对象的内存地址在运行时动态分配的，取决于对象的创建方式和程序的内存分配策略

## 如何让函数在main()函数之前被调用？
1.使用全局对象的构造函数
	- 可以通过定义一个全局(静态)对象，在其构造函数中调用所需的函数。
	- 由于全局对象的构造函数在main()函数执行之前被调用，可以确保函数提前执行。
2. 静态初始化块
	- C++11引入的静态初始化机制
	
40.5 主定理
	用于分析分治算法的时间复杂度	
		可以直接从递归关系中推导出算法的渐进时间复杂度

43. sizeof和strlen
	strlen不带'\0'
	
	TODO：
	vector[i]=4的底层实现/push的底层实现
	迭代器实现归并排序
	华为1，3题
	输入M,n
	第一题：问最小的组合实现覆盖
	
	第三题：IP
		要求IP组尽可能多，相同IP组要IP包含的尽可能小，最后要小IP
		
			sort自定义排序，如果相同返回的是什么
	
	手搓socket
	
	数组，实现归并
	
	进程间通信方式
	有名管道和匿名管道区别
	文件映射
	文件映射的优势，为什么非用不可
	虚拟内存多大？
	调度算法
	分页的优势
	
	Hash函数
	频繁发生冲突怎么处理？
	扩容后发生了什么？数组全部搬移吗？那你原来除留余法不是没解决频繁冲突问题吗？
	
	虚函数
	虚函数表和虚表指针

    序列和反序列化：
	本项目采用protobuf。
	功能是将类似于结构体的消息序列化为二进制数据。
	方法：protobuf提供的SerializeToString
	
在分布式系统下，RPC调用是一个高并发场景：有很多客户端和服务端建立TCP连接，发送服务调用请求。
	
动态代理？
	RPC服务端对外提供可调用方法: LoginResonse UserServiceRpc::Login(LoginRequest)
		接收入参对象LoginRequest并返回对象 LoginResponse
	在.proto文件中注册，使用protoc编译该文件，得到一组.cc和.h文件。这组文件可以和c++程序对接，
		利用protobuf提供的方法来封装要传输的消息结构体
		
服务发现
	客户端获取服务对象方法提供者地址信息的过程，称为服务发现。
	服务发现机制提供两个功能：
		1. 服务注册：服务提供方在提供服务前把自己的服务对象注册到注册中心上，
			注册中心把这个服务提供者的地址信息和提供的服务对象名和方法名保存下来。
		2. 服务订阅：在服务调用方 启动时，去注册中心找自己需要的服务对象对应的服务提供者的地址信息
			缓存到本地，为远程调用做储备。
	本项目使用zookeeper实现服务发现功能。
	
Wathcher机制来更新注册中心

项目流程?
	在user.proto中注册->调用protoc生成user.cc和user.h
	其中提供的Service虚类 包括UserServiceRpc和UserServiceRpc_stub类
		继承至UserService类做业务层实现。
		
	main()
	先框架初始化
	
	#define EXIT_FAILURE 1
	exit() 函数用于终止程序的执行并向操作系统返回一个退出状态码。
	通常有两种退出状态码：
		EXIT_SUCCESS：表示程序成功执行并正常退出，通常值为 0
		EXIT_FAILURE：表示程序执行失败，通常值为 1 或其他非零值
	
	getopt的用法：
	int getopt(argc, argv, "i:")
	i为命令行选项，如'i', 'f'
		返回值：正确获取到返回当前处理的选项字符，如'i'
				如果没有更多可解析字符，返回-1
	
std::unique_ptr
	C++11 引入的智能指针，用于管理动态分配的内存或资源
	std::unique_ptr<T, Deleter> ptr;
	这里T类型是FILE*, 所以unique_ptr被销毁时调用fclose关闭文件就行，不需要delete。
	
	char buf[1024]
	while(fgets(buf, sizeof(buf),pf.get())!=nullptr){
		string read_buf
	}
	
substr()用法
	string substr (size_t pos = 0, size_t len = npos) const;
	
NotifyService()
	定义结构体ServiceInfo保存服务信息
			成员:	Service* service
					unordered_map method_map
	定义mp service_map保存
	从google::protobuf::Service()->GetDescriptor()中获取服务信息：method()和name()
		打印并存至method_map中。
	将服务名和ServiceInfo再存到service_map中
	
atexit()
	int atexit(void (*func)(void));
		C标准库中的一个函数，用于注册程序退出时需要调用的清理函数。
		注册的函数将在程序正常退出时被调用，
		无论是通过 exit() 退出，还是通过程序的 main() 函数结束时退出。
		
this指针
	this指针指向当前对象的实例，
	在非静态成员函数中可用
	
	
protobuf, service->GetDescriptor
	获取的是在service.proto中注册的服务和方法
	服务为UserServiceRpc, 方法为Login, Register, 原定义如下：
		service UserServiceRpc{
		rpc Login(LoginRequest) returns(LoginResponse);
		rpc Register(RegisterRequest) returns(RegisterResponse);
		}

构造拷贝函数(copy operator)
	Myclass (const Myclass &other){}
重载赋值函数(copy assignment operator)
	Myclass& operator=(const Myclass &other)
	
=delete特性
	用来明确禁止某个函数的调用
	
strerror_r
	int strerror_r(int errnum, char *buf, size_t n);
	参数：
		-errnum: 	错误代码
		-buf；		用户提供的存储错误描述的缓存
		-n:			缓存的大小
	
. 和 -> 
	都用于访问对象的成员
	-有一个对象的实例（变量）时，可以使用点运算符 . 来访问其成员
	-当你有一个指向对象的指针时，需要使用箭头运算符 -> 来访问该对象的成员
			
数据类型
	short int long, long long
		short至少16位
		int至少和short一样长
		long至少32位，且至少和int 一样长
		long long至少64位，且至少和long 一样长
	
		8位bit=1字节
		
		unsigned：无符号，不存负数，存负数空间全拿来存正数
	
前置++和后置++的内部实现
	前置++直接修改并返回变量
	后置++创建一个临时拷贝，修改原变量后返回临时拷贝
	
atomic
	原子变量, 确保在多线程环境中线程安全执行
	Q: a++ int a=b；这两条语句是原子的吗？
	A: 不是，从编译器角度说，需要先将变量a对应的内存值搬运到某寄存器中，
		然后对该寄存器的值增1或改动，最后搬回内存。在这期间线程可能会改变
		
分布式系统：就是说多个计算机或节点协同完成任务。

## 1. 函数定义
### 定义在头文件会怎么样？
- 优点：	
1. 易于代码复用，可以方便多个源文件(.cpp)包含并使用这些函数
2. 内联优化：将小型函数定义在头文件，编译器有更多机会进行内联优化
    所以内联函数(使用inline修饰)通常在头文件定义  
- 缺点：	
1. 多重定义：一个函数定义在头文件，而该头文件被多个源文件包含，在链接阶段会出现"重定义"错误  
因为每个包含该头文件的源文件都生成了一个函数实例，编译器无法确定哪个版本
- 解决办法：
    - 使用inline关键字：  
        告诉编译器允许在多个翻译单元中存在该函数的定义，从而避免重定义错误  
        同时,编译器可能会将该函数进行内联展开，提升执行效率

### 模板函数应该定义在哪里？
模板函数的实现通常定义在头文件。因为模板在编译时进行实例化，编译器需要在使用模板时看到完整定义，以便根据类型生成相应代码。
		
7. 三字符组
	用于表示另一个字符的三个字符序列，又称三字符序列。总是以两个问号开头
	从 c++10开始默认不再自动替换三字符组。

8. 基本的数据类型
	bool, char, int, float, double, void
	
	修饰符
	signed(有符号，默认)
	unsigned
	short
	long 
	const 
	volatile 	变量可能被意外修改，禁止编译器优化
	mutable 	类成员可以在const对象中修改

## 访问控制
C++ 中类成员（变量和函数）的访问权限由三个关键字控制：
- private
- protected
- public

| 访问权限  | 类内访问 | 派生类访问 | 类外访问（对象访问） | 说明                         |
|-----------|----------|------------|---------------------|------------------------------|
| `private` | 可访问   | 不可访问   | 不可访问            | 仅限于本类内部使用            |
| `protected` | 可访问 | 可访问     | 不可访问            | 本类和派生类可访问，外部不可访问 |
| `public`  | 可访问   | 可访问     | 可访问              | 对所有代码开放                |

### private
只能在本类成员函数内部访问, 常用来隐藏实现细节，保护数据安全

### protected
可以被本类和派生类访问, 常用于希望派生类访问但不想暴露给外部的成员

### public
对所有代码开放访问, 常用于接口函数和需要外部访问的数据

### 默认设置
- 类（class）成员默认是 private
- 结构体（struct）成员默认是 public

#### 访问权限与继承方式权限变化

| 基类成员访问权限 | `public` 继承中派生类访问权限 | `protected` 继承中派生类访问权限 | `private` 继承中派生类访问权限 |
|------------------|-------------------------------|---------------------------------|-------------------------------|
| `public`         | `public`                      | `protected`                     | `private`                     |
| `protected`      | `protected`                   | `protected`                     | `private`                     |
| `private`        | 不可访问                     | 不可访问                       | 不可访问                     |

### 补充
- 友元（friend）：友元函数或友元类可以访问类的所有成员（包括 private 和 protected）。
- 访问控制是编译时机制，不影响内存布局。

## 深拷贝 & 浅拷贝
### 浅拷贝
复制对象时，**仅仅**复制对象的成员变量的值。如果成员变量是指针，只复制指针的地址，不复制指针指向的内容。

- 两个对象共享同一块资源(内存)
- 修改一个对象指针指向的数据会影响另一个对象
- 一个对象析构释放了资源，另一个对象的指针就会悬空，容易导致程序崩溃。
- 如果对象的成员变量是非指针类型(int、double、char、结构体等), 浅拷贝直接复制这些成员的值，复制后新旧对象各自拥有独立的成员变量空间。

### 深拷贝
在复制对象时，**不仅**复制对象的成员变量的值，还会复制指针指向的资源，重新分配内存，并将内容复制过去。即:
- 新对象拥有自己独立的资源。
- 新旧对象互不影响。
- 解决了浅拷贝导致的悬空指针和资源冲突问题。

| 方面    | 浅拷贝             | 深拷贝             |
|------------|-------------------|--------------------|
| 拷贝内容   | 仅复制成员变量值（指针地址）  | 复制成员变量值及指针指向的数据    |
| 资源共享  | 是，指针成员指向同一块内存     | 否，指针成员指向不同内存          |
| 互相影响 | 修改一个对象的数据会影响另一个   | 互不影响                         |
| 析构时风险 | 可能出现双重释放 | 不会出现双重释放     |
| 实现复杂度   | 简单，编译器默认实现即可   | 需要自定义拷贝构造函数           |
| 性能开销     | 低      | 较高（需要额外的内存分配和复制） |

### 函数参数传递方式

总览：

| 参数类型       | 默认传递方式   | 说明                             |
|----------------|----------------|----------------------------------|
| 基本类型       | 按值传递       | 复制值，函数修改不影响调用者     |
| 指针           | 按值传递       | 复制指针地址，指向数据共享       |
| 数组           | 退化为指针传递 | 传递数组首地址，数据共享         |
| 结构体         | 按值传递       | 复制整个结构体，浅拷贝           |
| C++ 引用       | 引用传递       | 直接操作调用者变量               |
| C++ 类对象     | 按值传递       | 调用**拷贝构造函数**，可能浅拷贝或深拷贝 |

1. 基本数据类型(如 int, float, char, double 等)
调用函数时，参数的值会被复制一份传入函数，函数内部对参数的修改不会影响调用者的变量。
2. 指针类型(如 int*, char* 等)
函数接收到指针的副本(指针地址的拷贝)，但指针指向的内存是同一块，因此函数可以通过指针修改指向的数据。
3. 数组类型
数组名在函数参数中退化为指针，实际传递的是指针；  
数组本身不会被拷贝，函数接收到的是数组首元素的地址
4. 引用类型
传递引用，函数参数是被调用者变量的别名，函数内的修改会影响调用者变量。
5. 类或对象
- 默认按值传递（调用该类的拷贝构造函数，浅拷贝或深拷贝取决于类实现）
- 推荐传引用或传指针以避免性能开销

##### sort
``` cpp
sort(nums.begin(), nums.end(), greater<int>());
```

自定义
``` cpp
sort(arr.begin(), arr.end(), [](const vector<int>& a, const vector<int>& b) {
	if (a[0] != b[0])
		return a[0] < b[0];   // 第一列升序
	else
		return a[1] > b[1];   // 第二列降序
});
```

## 代码编译过程
### 1. 预处理(Preprocessing)
### 2. 编译
### 3. 汇编
### 4. 链接
将多个目标文件和库文件合并。

