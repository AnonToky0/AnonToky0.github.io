---
title: "C++"
date: 2025-08-25 23:00:00 +0800
categories: [C++]
tags: [标签1, 标签2]
---

在类中: 
> 方法=成员函数，属性=成员变量

## 面向对象(Object Oriented Programming, OOP)
c++三大特性：封装、继承、多态
(也有说法是四大特性，第四个特性是抽象)

### 封装
将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。
### 继承
从已有类中派生出新类，新类具有已有类的属性(成员变量)和方法(成员函数)。  
并且扩展或修改这些属性和方法。

#### 继承列表：
``` C++
class 派生类 : [访问控制] 基类1, [访问控制] 基类2, ... {
    // 成员变量和成员函数
};
```
在冒号后的就是继承列表

##### 菱形继承问题：
一个类通过多个路径继承自同一个基类时，形成类似菱形的继承结构。  
可能导致基类被多次继承，从而引发二义性和资源冗余问题。

二义性：
    假设出现菱形继承, B::A, C::A, 而D::B,C
    当创建D对象并访问A成员时，编译器无法确定通过哪一个A类子对象来访问
	
	
	
	解决方案：虚拟继承
		基类在继承层次结构中只存在一份实例，从而避免冗余和二义性问题
		原理：
			1. 共享基类实例：所有通过虚拟继承从同一个基类继承的路径，共享一个基类的实例
			2. 基类子对象唯一性：在最终派生类中，基类只出现一次。
		语法：
			在继承时使用virtual关键字
				class Derived : virtual public base {}
		虚拟继承对构造函数影响
			使用虚拟继承情况下，构造最终派生类对象时，构造函数调用顺序如下：
			1. 基类构造：
				先 虚拟基类的构造函数：无论虚拟基类在继承列表中的位置如何，虚拟基类的构造函数总是最早被调用
				后 非虚拟基类的构造函数
					如果有多个非虚拟基类，构造顺序取决于它们在继承列表中的声明顺序，而不是在类定义中的顺序
			2. 派生类成员变量的构造
				按照在类中的声明先后顺序被构造
			3. 派生类的构造函数
		虚拟继承对析构函数影响
			与构造函数相反：
			1. 派生类的析构函数
			2. 非虚拟基类的析构函数
			3. 虚拟基类的析构函数
	
	Q. 为什么先成员变量构造再构造函数？
		在构造之前确保所有成员变量已正确初始化
	
	Q. 成员变量构造之后内存分配位置：
		取决于对象本身的分配方式
			当对象是局部变量，它及所有成员变量放在栈上
			使用new创建的对象及其成员变量分配在堆上
			全局或静态对象分配在数据段或静态存储区

4.3 多态
	构造顺序：
		创建一个派生类对象时,构造函数的调用顺序遵循以下规则：
			1. 虚拟基类的构造
			2. 非虚拟基类的构造
			3. 成员函数的构造
			4. 派生类自身的构造
		这种顺序确保虚拟基类在整个继承树中只被构造一次，并且在其他基类和成员对象之前完成，从而避免多次构造同一基类的问题
		
		1. 虚拟基类的构造
			[虚拟继承]用于解决多重继承中的菱形继承问题，确保虚拟基类在继承层次结构中只存在一个实例。
		2. 非虚拟基类的构造
			
		3. 类的成员对象
		4. 最后执行派生类的构造函数体
### 多态
同一种操作作用于不同对象，可以有不同解释和实现。
- 静态多态：通过**函数重载**或****运算符重载**实现，编译时确定调用哪个函数
- 动态多态：又称函数重写，通过**虚函数**和**继承**实现，运行时根据对象的实际类型调用对应的函数。
### 抽象
从具体实例中提取共同的特征，形成抽象类或接口，以便代码的复用和扩展。

#### 抽象类
**抽象类**是指至少包含一个纯虚函数的类。抽象类不能被实例化，只能作为其他类的基类，作为定义接口和共性行为。 
抽象类不能实例化，通常作为其他类的基类，提供接口和部分实现。
``` C++
class Abstract{
public:
    virtual void ab() = 0;
};
```
    
#### 纯虚函数
在基类中声明但不提供实现的函数，子类必须重写(实现)这些函数。
子类不重写的话必须也是抽象类。
``` C++
class Shape{
public:
    virtual double area() const = 0;
    
    virtual void describe() const{
    cout<<"output"<<endl;
    }
}
```
			
## 1. C语言指针
指针是一个变量，其值为另一个变量的内存地址。  
通过指针，程序可以间接访问和操作内存中的数据。

### 指针用途：
- 动态内存分配：		运行时分配和释放内存
- 数组和字符串处理：	高效访问和操作数据元素
- 函数参数传递：		通过指针实现传值和传地址
- 数据结构实现：		如链表、树、图

### 指针声明：
指针的声明需要指定其所指向的数据类型，举例
``` C
int *p;      // p是一个指向int类型数据的指针
char *cptr;  // cptr是一个指向char类型数据的指针
```
使用&运算符获取变量的内存地址，举例
``` C
int a = 10;
int *p = &a;  // 用&运算符获取变量a的地址，并赋给指针p
```
使用*运算符访问指针指向的值
``` C
int a = 10;
int *p = &a;
printf("%d\n", *p);  // 输出a的值，即10
```

### 指针运算：
指针可以加减运算，但增减操作会根据指针类型大小进行偏移
``` C
int(*p)[3] //p是一个指向含有3个元素数组的指针
```
每次p+1，将移动到下一个含有3个整数数组的位置
    
C语言中[]操作符优先级高于*解引用  
即`*p[i]`会被解析为`*(p[i])`
	
## 1.1 C和C++区别
1. 编程泛式
- C是过程式编程语言，强调通过函数和过程组织代码  
- C++支持过程式、OOP、泛型和函数式编程等多种编程范式
    C++通过引入面向对象编程，使得代码更具模块化和可重用性
> 什么是过程式编程语言: 以“过程”（Procedure）或“函数”（Function）为基本组织单位,程序从上到下依次执行。
2. 内存管理
- C使用malloc, calloc, realloc和free进行动态内存分配和释放
- C++更加灵活，使用new和delete，简化内存操作
    - 引入智能指针来自动管理内存，减少内存泄漏风险
    - 使用RAII(资源获取即初始化)，通过构造函数和析构函数自动管理资源
3. 标准库
- C提供标准C库
- C++提供标准模板库(STL)
4. 函数
- C仅支持函数，不支持成员函数(方法)
    - 支持函数指针
- C++类中可定义成员函数，支持方法的重载和多态
    - 允许通过虚函数实现运行时多态
    - 同名函数可重载
5. 异常处理
- C语言没有内置异常处理机制，通常依赖返回值、全局变量(如errno)
- C++支持try, catch, throw, 提供结构化的异常处理机制
    - 提供丰富的标准异常类，如std::exception, std::runtime_error等
6. 模板和泛型编程
- C语言不支持模板和泛型编程，可通过宏实现部分代码泛型化
- C++支持函数模板和类模板
    - 模板元编程：允许在编译时进行复杂的计算和类型操作
6. 命名空间
C++引入命名空间(namespace),可以将函数、类、变量组织在不同的命名空间中，避免命名冲突
7. 输入输出
- C使用标准I/O库，使用stdio.h中函数，依赖格式化字符串进行数据的输入输出
- C++使用输入输出流
    - 通过重载运算符实现类型安全的输入输出操作
    - 支持自定义输入输出
8. 兼容性
- C语言通常用于系统性编程，与底层硬件和汇编语言有良好兼容性
- C++向后兼容C，大部分C代码可以在C++中编译和运行
    - 可以调用C库，通过extern "C"实现名称修饰的兼容

### 1.2 标准I/O
- scanf:默认会读取直到遇到空白字符(空格、换行、制表符)为止的所有字符
``` C
scanf("%5s", a);
```
- gets:读取一行的输入，直到遇到换行符。因为不执行缓冲区大小的检查，容易导致缓冲区溢出，所以从C11开始被移除
- `fgets(buf, sizeof(buf), stdin)`:读取最多sizeof(a)-1个字符
- 以上都是C风格的字符串，所以都会往末尾添加'\0'
					
2. 函数指针：

	//定义一个函数
	void greet(){
		std::cout<<"Hello World"<<std::endl;
	}

	//定义一个函数指针，指向返回类型为void， 参数为空的函数。
	void （*funcPtr)();
	
	//将函数指针指向greet;
	funcPtr=&greet;
	
	//通过函数指针调用
	funcPtr();
	
	//将函数指针指向另一个函数
	funcPtr=&greet2;
	funcPtr();
	
3. 指针函数
	返回类型为指针的函数。即该函数执行后返回一个指针。
	用途：
		1. 动态分配内存后返回指针
		2. 返回指向特定类型的对象的指针
		3. 提供对某些数据结构中元素的访问
		
	1. 动态分配内存：
		int *getNumber(){
			int *ptr = new int(42);
			return ptr;
		}
		返回int*类型的指针。
		
		int main(){
			int* numPtr = getNumer();
			std::cout<<*numPtr<<std::endl; //输出42
			
			delete numPtr;
			return 0;
		}

5. const
	const关键字用于声明变量为"常量"，即该变量的值在初始化后不可更改。
		不仅适用于基本数据类型，也适用于指针、引用、类成员等多种场景。

		
	1. 修饰变量
		const int MAX_SIZE = 100；
	2. const指针
		2.1 指向常量的指针(pointer to Const)/ 常量指针
				指针指向的数据不能通过这个指针修改
				可以改变常量指针的指向其他地址
		2.2 指针常量
			指针本身是常量，即指针的地址不能被修改，但可以通过它来修改地址里内容
				int a = 5;
				int b = 10;
				int *const ptr = &a;
				*ptr = 20; // 合法。 可以修改指向的数据
				// ptr=&b; //不合法，指针常量的地址不能改变
		2.3 指向常量的常量指针
			指针本身(地址)和指向的内容都不能修改
	3. const函数应用
		3.1 作为参数
			3.1.1 传值参数中的const
					const修饰传值参数 对调用者没有影响，因为传值参数在函数内部就是副本，
					仅仅是防止在函数内部修改变量
			3.1.2 传引用
					对引用或指针参数使用const，防止函数修改调用者的数据
		3.2 返回类型
			函数返回类型可以被声明为const。对于按值返回的函数没意义，因为传回的是副本。
			如果返回是引用或指针类型的，可能会导致篡改类内数据。
			使用const 修饰按引用或按指针传递的返回类型，可以避免修改原始数据。
	4. const类内使用
		4.1 const成员函数
			特点：
			1. 不修改对象的状态：
				函数在执行过程中不会修改对象的任何成员变量(除非成员变量被声明为可变)
			2. 只能调用其他常成员函数：
				在这个成员函数内部，只能调用其他被声明为const的成员函数
					确保不会通过间接调用修改对象状态。
			3. 可以通过[常量对象]或[常量引用/指针]调用这个成员函数。
			4. 非const对象也可以调用const成员函数
			5. 基类和派生类中, const修饰必须一致，以确保多态性和正确性
			6. 临时对象默认是const, 只能调用const成员函数
			
		4.2 const对象:
			在对象的声明前使用const关键字
			在声明时被指定为const的对象。意味着对象一旦被创建，其状态(成员变量的值)不能被修改。
				对于类的对象，可以同样使用const
				
				class point{
				public:
					int x_, y_;
					Point(int x, int y): x_(x), y_(y){}
					void move(int dx, int dy){
						x+=dx;
						y+=dy;
					int getx() const {return x_};
					int gety() const {return y_};
				};
				//实例化对象
				const Point p(1,2);
				cout<<p.getx()<<endl;
		
			特点：
				不可修改
				只能调用const 成员函数
		4.3 const成员变量
			类的成员变量可以声明为const, 需要在初始化列表中进行初始化，且不可更改。
				初始化列表就是指构造函数中根据传入值初始化。	
	5. const与类型转换
		5.1 const_cast
			用于移除或添加对象的const属性，主要用于指针和引用
			滥用const_cast可能导致未定义行为
		5.2 static_cast
			不会修改const属性
			
	6. const变量和宏变量有什么区别
		6.1 const变量有明确类型，编译器会进行类型检查，确保类型安全。
			宏只是简单文本替换，没有类型信息。
		6.2 作用域
			const遵循c++作用域规则，可以定义在局部或全局范围，具有明确作用域
			宏在定义后，直到文件结束或被#undef，在整个预处理范围内有效，可能导致命名冲突
		6.3 编译器处理
			const由编译器处理，具有类型信息和作用域，能进行优化，如内联替换
			宏变量由预处理器处理，仅文本替换，不参与编译器的类型检查和优化
		6.4 调试
			调试时const变量有明确的地址和值
			宏在预处理后被替换，没有独立的实体

5.1 constexpr
		constexpr是const exprssion的缩写，用于指示编译器某个值或表达式可以在编译期间求值。
	1. constexpr变量
		constexpr变量必须在定义时初始化，并且初始化表达式必须在编译时可求值。
	2. constexpr函数
		在编译时可求值的函数，用constexpr修饰返回值
		c++11版本，函数体内仅包含一条return 语句。
		c++14版本后可以包含多条语句，如条件判断、变量声明等。 
	3. constexpr与类
		4.1 constexpr构造函数
			被constexpr修饰的构造函数，其所有成员必须是字面类型
			[字面类型]:可以在编译时计算的类型，比如int, double
				字面类型包括：标量类型、引用类型、数组类型、满足条件的类或结构体
			当声明一个对象为constexpr时，整个对象及其成员的初始化在编译时完成。
			在constexpr构造函数中，只能执行那些在编译时求值的操作。
		4.2 constexpr成员函数
			函数必须声明为constexpr
			函数体内所有操作必须在编译时可求值
		4.3 constexpr静态成员变量
			必须在类内声明为static constexpr
		
	constexpr的规则和限制
		1. 必须在定义时初始化
		2. 初始化表达式必须是编译时常量
		3. constexpr构造函数类的成员变量必须在编译时初始化，不允许有虚函数或虚继承。因为编译器无法确定具体调用哪个虚函数实现。
		4. 类型限制：只有字面类型才能用constexpr修饰

6. 二叉搜索树(查找树)
	左子树结点值小于根结点值
	右子树结点值大于根结点值
		
7. 三字符组
	用于表示另一个字符的三个字符序列，又称三字符序列。总是以两个问号开头
	从 c++10开始默认不再自动替换三字符组。

8. 基本的数据类型
	bool, char, int, float, double, void
	
	修饰符
	signed(有符号，默认)
	unsigned
	short
	long 
	const 
	volatile 	变量可能被意外修改，禁止编译器优化
	mutable 	类成员可以在const对象中修改
	
9. extern
	用于声明变量或函数在其他文件中定义。
	主要用于实现[跨文件的变量和函数共享]，帮助编译器了解变量或函数的存在，而不必在当前文件重复定义。
	
	1. 声明外部变量
		一个变量在一个文件中定义后，如果需要在其他文件中使用该变量，就需要使用extern关键字声明。
			可以用于声明类的外部对象，注意是对象，
				1.	在一个源文件中(如main.cpp)定义类的对象
				2. 	在一个头文件中使用extern声明该对象
				3.	在其他需要使用该对象的源文件中包含该头文件，从而访问同一对象
	2. 声明外部函数
		函数在一个文件中定义后，可以在其他文件中使用，无需再次定义，但可以通过函数原型进行声明。
		这里说的外部函数通常是全局函数，即具有全局链接。
			使用static关键字声明的全局变量具有内部链接，仅在定义它的源文件可见，所以这类函数不适用于extern
	3. 链接规范
		用于指定使用C语言的编译方式。常用于c和c++的混合编程，避免名称修饰导致的链接错误。
		
		链接规范：
			c++支持函数重载，相同的函数名称可以传入不同参数列表，通过[名称修饰]实现
			然而c不支持函数重载，所以为了在c++中调用C或让C调用c++函数，使用extern "C" 避免名称修饰.
			
			[名称修饰]：
				是编译器在编译过程中对函数名、变量名等进行的一种转换。
					转换的目的是为了支持某些语言特性，比如函数重载、类成员函数等。
					名称修饰使得编译器在生成的目标代码中唯一地标识每个函数和变量，即使他们在源代码中有相同名字。
			
			作用：
				告诉c++编译器，将指定函数用C规则编译(不用名称修饰)
			
			用法：
				在函数声明上面加一个extern "C",
				由于是函数申明所以一般放在头文件里。
	注意事项：
		1. 避免多重歧义：
			使用extern可以防止多个文件中重复定义同一个变量或函数，
				但需要确保每个全局变量或函数在整个程序中只有一个定义。
		2. 初始化外部变量
			extern声明的变量不能初始化。初始化只能在变量定义时进行。
			extern int gVar =10; //这会编译错误。
		
		3. 若在多个文件中使用extern声明但没有提供相应定义，会导致链接错误。
		4. 局部变量
			extern关键字用于声明全局变量或函数，不能用于局部变量。
		5. 命名空间影响
			c++中，extern声明也受限于命名空间。
			
10. static
	1. 静态变量
		1.1 全局静态变量
			在文件作用域中定义。
			特点：
				内部链接，即该变量只在定义它的源文件中访问，无法被其他源文件使用。有助于实现封装，防止命名冲突。
		1.2 局部静态变量
			在函数或代码块内部使用。
			特点：
				静态存储期，变量在程序运行期间只初始化一次，在多次函数调用期间保持其值。
	2. 静态函数 
		static关键字作用于函数, 分为全局静态函数和类中静态函数
		2.1 全局静态函数
			内部链接，只能在定义他的源文件中调用，不能被其他源文件访问
	3. 类的静态成员
		3.1 静态成员变量
			静态成员变量属于整个类。所有类的实例共享同一个静态成员变量。
				静态成员变量必须在类外进行定义。
				这里定义一般放在类定义(如A.cc)所在的文件里。注意不能在main()里初始化,main也是函数有局部作用域
					由于静态成员变量与类的所有实例共享，因此必须在一个确定的翻译单元中进行定义，以避免链接时出现重复定义或未定义错误。
				可以不初始化，不初始化编译器会分配默认值：内置类型如(int, char)置零，类类型调用对应默认构造函数
				常态静态成员变量(且是整型)可以在类定义内初始化。

		3.2 静态成员函数
			类中静态函数属于整个类，而不是某个特定对象。可以在没有类实例的情况下被调用，通过类名::
			静态成员函数只能访问静态成员变量和其他静态成员函数，不能访问类的非静态成员。
	4. 静态存储期
		静态存储期指变量在程序的整个生命周期存在。使用static关键字声明的变量具有静态存储期。
			无论作用域如何(全局、静态变量、类的静态成员)，都在程序开始时分配内存，在程序结束时释放内存。
	5. 其他用法
		5.1 匿名命名空间
			就是不带名字的namespace, 可以取代全局静态变量和全局静态函数的使用，有更好的灵活性和可读性
	6. 存储位置
		静态变量和全局变量都在数据段
		静态局部变量也在数据段而不在栈。
			Q1:静态成员变量何时被分配到内存的数据段？
			A1:在程序加载(编译->链接->加载)时被分配到内存的数据段
				全局静态成员变量在程序启动时被初始化, 并在整个程序运行期间存在。
				局部静态成员变量在程序第一次执行到定义所在代码时被初始化, 并在整个程序运行期间存在。
				具体来说：	在编译阶段：编译器识别类中的静态成员变量，并为其分配内存地址
								由于静态成员变量通常定义在对应.cpp文件中，编译器在该文件的符号表中为其分配一个全局符号
							在链接阶段：链接器将所有翻译单元中的符号解析并分配到最终可执行文件中
							在程序加载阶段：将可执行文件加载到内存中，分配数据段的空间存储静态成员变量
	7. 静态方法不能是虚方法
		静态方法(静态成员函数)不依赖于对象实例，而虚方法需要通过对象实例调用。
			通过基类指针或引用调用虚方法时，会根据实际对象类型执行相应的重写方法。
			
	8. c++11新特性
		c++11在语言标准中明确规定，局部静态变量的初始化是线程安全的。这意味着：
			1. 单次初始化：	无论多少线程同时调用包含局部静态变量初始化的函数，变量只会初始化一次。
			2. 同步机制：	编译器会自动处理必要的同步，确保变量完全初始化之前，其他线程无法访问该变量
			3. 无数据竞争：	消除因多线程竞争导致的初始化数据竞争问题。
			
11. 指针
	1. 什么是指针
		指针是一个变量，用于存储另一个变量的地址。
		换句话说：指针指向某个数据的内存位置。
		所有指针的值的实际数据类型，都是一样的，是一个代表内存地址的长的十六进制数。
	2. NULL指针
		在指针变量声明时，如果没有明确地址可以赋值，为指针变量赋一个NULL是好的编程习惯。
		大多数操作系统不允许访问地址为0的内存，因为这是给操作系统保留的。
		对于指针来说，指针的值为NULL代表它不指向任何东西。
	3. 指针的算术运算
		指针是一个用数值表示的地址，可以对指针进行四种算术运算: ++, --, +, -
		指针算术运算是根据指针类型和大小决定的。
		如果是一个int* 类型的指针，每次++会移动4个字节，因为这代表指向下一个int的内存地址
		
		3.1	指针的比较
			相等性比较：	检查两个指针是否指向相同位置
			关系比较(<,>)：	确定一个指针是否指向的位置在另一个指针之前或之后。
							通常在指针指向同一个数组的元素时有意义。
	4. 指针和数组
		C风格的数组(arr[]), 数组名会退化为指向数组第一个元素地址的指针。
			比如： 	int arr[] = {1,2,3};
					int *p = arr;
			但是对arr++来试图访问其他成员是错误的。(简单来说可以通过*arr来访问第一个元素的值，但是不能修改arr本身地址的值)
		c++风格的数组(array, vector)不会退化。
			数组提供了成员函数data()来返回指向第一个元素的指针。
	5. c++指针数组
		让数组存储指向int或其他数据类型的指针。
		比如：	int *ptr[MAX];
			这里ptr是一个数组，由MAX个整数指针构成。ptr中每个元素，都是一个指向int值的指针。
	6. 指向指针的指针(多级间接寻址)
		比如：指向int类型指针的指针：int **var;
				即：var里存了一个int类型指针的变量的地址
	7. 传递指针给函数
		定义一个变量，把它地址传递给函数，在函数内通过*修改其地址的值。
		
	8. 指针资源的释放(delete)：
		指针变量和指针所指对象的不同，指针变量存储的是内存地址。*ptr或ptr所指向对象是存储在该内存地址上的实际数据或对象。
		当调用delete ptr，实际上是在释放ptr所指向对象的内存(将对应内存地址收回标记为可用)
			所以delete ptr只释放了ptr所指向的内存，而不是ptr变量本身的内存。
			删除后, ptr仍是一个合法的指针变量，但是现在指向一个已经释放的内存，即它现在是一个悬挂指针。
		ptr可以被重新赋值，或者置空避免指针悬挂。
		
	9. 悬挂指针：
		指针指向一个已被释放的内存地址
		使用悬挂指针可能会访问到非法地址，导致错误
		
12. 智能指针
	智能指针是c++中一种封装原生指针的类模板。通过RAII(资源获取即初始化)机制，实现对动态分配内存的自动管理。
	核心设计思想：
		1. 对象生命周期绑定:智能指针对象的析构函数自动释放所管理的内存，无需手动delete
		2. 所有权定义：		通过类型系统(独占或共享)明确资源的所有权归属，避免内存泄漏或非法访问
		
	常见智能指针：
		unique_ptr: 独占所有权，同一时间仅允许一个指针管理资源
		shared_ptr: 共享所有权，通过引用计数管理资源生命周期
		weak_ptr:	弱引用，配合shared_ptr解决循环引用问题， 不增加引用计数
	
	核心作用：
		1. 自动内存管理：当智能指针对象超出作用域时，析构函数自动调用delete或自定义删除器释放资源
				即使程序异常中断，智能指针仍能确保资源释放，避免传统指针因代码分支遗漏释放的问题
		2. 防止悬空指针：
				shared_ptr在引用计数归零后，自动将内部指针置为nullptr，避免访问已释放的内存区域。
		3. 管理共享资源的所有权：
				shared_ptr允许多个指针共享同一资源，计数归零时自动释放
				unique_ptr确保资源仅被单一所有者控制，适用于需要严格独占的场景。
		4. 解决循环引用问题
			weak_ptr不增加引用计数
			
	12.1 unique_ptr
		独享被管理对象指针所有权
		包装一个原始指针，并负责其生命周期。当该对象被销毁时，在其析构函数中delete原始指针
		独享所有权：
			unique_ptr始终是关联的原始指针的唯一所有者，无法复制unique_ptr对象，只能移动。
			不能通过赋值的方式传递对象
			不能通过拷贝构造函数或拷贝赋值运算符创建unique_ptr对象的副本
			但是可以通过std::move转移资源所有权
			
	12.2 shared_ptr
		共享所有权，多个shared_ptr可以共同拥有同一个资源
	
		shared_ptr线程安全吗？
		-引用计数是线程安全的
		-指针所指向对象是不安全的，shared_ptr仅负责管理对象的生命周期，不负责对象本身的线程安全性
			因此，如果多个线程同时访问或修改shared_ptr所指向的对象，需要额外的同步机制(如互斥锁)来确保线程安全
			
	12.3 weak_ptr
		不影响引用计数、不能直接访问资源，需要通过lock()方法提升为shared_ptr才能使用
		用于检查资源是否依然存在
			
13. noexcept
	c++11引入，所修饰的函数在执行过程中不会抛出异常
		这意味着catch不会捕获到异常
		
14. 空类
	c++为空类自动实现的函数包括：
		默认构造函数
		默认析构函数
		拷贝构造函数
		移动构造函数
		拷贝赋值运算符：将一个已有对象的内容赋值给另一个对象
		移动赋值运算符
		
	空类的大小至少为1字节。这是由c++标准决定的，确保每个对象有唯一的地址。
	
	空基类优化：
		当空类作为其他类的基类时，编译器可能会应用空基类优化，从而使继承类的大小不因空基类而增加。
		比如class parent: public Empty
			{
				int val;
			};
			parent带有一个4字节的val，但parent类可能只占4字节。
		
15. this指针
	this指针是一个特殊的指针，在c++类的成员函数中使用。它指向调用该成员函数的对象的地址。
		相当于在当前对象上调用成员变量或成员函数
		它的引入主要是为了解决成员函数参数和成员变量同名的问题。
	使用场景：
		1. 使用this指针明确指出要访问的是成员变量
		2. 返回当前对象本身，使用return *this。
		3. 在函数中访问当前对象的地址，使用this指针来获取。
		
	特性：
		类型是 类类型* const, 即成员函数不能给this赋值
		this指针是成员函数第一个隐含的指针形参，一般情况下由编译器通过ecx寄存器自动传递
		禁止在静态成员函数中调用：静态成员函数不属于任何对象。
		允许链式调用：通过返回*this.

16. virtual
	用于声明虚函数的关键字。
		虚函数允许在继承层级结构中实现动态绑定，即在运行时根据对象的实际类型调用相应的函数，而不是根据指针或引用的静态类型。
	虚析构函数
		当使用基类指针删除子类对象时，如果基类的析构函数不是虚函数，可能导致资源泄漏。
		确保正确调用子类的析构函数
		
		资源泄漏的原因：如果基类的析构函数不是虚函数，会调用基类的析构函数。
	
	虚函数表
		虚函数表是用来支持运行时多态的机制。当一个类声明了虚函数时，编译器为该类生成一个虚函数表。
			这个表包含指向该类所有虚函数的指针。
	虚表指针
		每个对象中有一个指向虚函数表的指针，称为虚表指针
	
	实现原理：
		虚表(vtable)是一个静态表格，存储了指向类的虚函数的指针。
		虚表指针(vptr)：每个对象包含一个隐藏的指针，指向该对象所属类的虚表。
			vptr通常在对象的内存布局中位于最前面。
	工作机制：
		当对象被创建时，构造函数负责初始化vptr,让它指向所属类的虚表。
			对于继承关系，子类的构造函数会覆盖父类的vptr，指向子类的虚表。
		当通过基类指针或引用调用虚函数时，编译器生成代码，通过对象的vptr访问虚表，从虚表中找到相应的函数指针，并调用该函数
		在多继承中，每个基类都有自己的虚表。派生类的对象将包括多个vptr,每个指向不同基类的虚表。
	实现细节:
		虚表通常保存在只读数据段中，防止被意外修改。
		每个对象的内存布局中自动插入一个vptr，指向类的虚表。
		当子类重写虚函数时，子类的虚表会包含指向子类实现的函数指针，覆盖父类的相关条目。
	
	为什么构造函数不能是虚函数？
		构造函数是用于对象初始化的，而虚函数依赖于虚函数表，虚函数表的建立是在对象构造过程中设置的。

17. Hash
	Hash是一种常见的用于快速存储和查找的数据结构和算法。最常见的Hash数据结构是Hash表(Hash Table)。
		Hash表通过将键(Key)映射到值(Value)的方式，实现高效的数据查找。
		组成：
			1. 数组：用于存储数据的主结构，称为桶(bucket)，每个存储单元为一个桶
			2. 哈希函数：将键映射到数据索引的函数
			3. 冲突处理机制：处理不同键映射到同一数据位置的情况
			
	1. 哈希函数
		一个好的哈希函数应具备以下特性：
			-确定性：相同输入始终产生相同输出
			-均匀性：均匀地分布输入，减少冲突
			-高效性: 计算速度快，适用于高频调用
		实际操作中会对Hash值取模以适应桶大小
		常用哈希函数：
		1.1 除留余法：
			Hash(key)=key%TableSize
				简单易实现，但当输入有规律时，可能导致冲突增多
		1.2 乘法散列法：
			将输入乘以一个常数A，取其小数部分，再乘以表大小并取整。
			Hash(key) = [TableSize*(key*A mod1)]
			A是一个介于0~1的常数，通常取(√5−1)/2, 即黄金分割比
		1.3 通用字符串哈希函数，如Djb2, sdbm
			
	2. 冲突处理机制：
		不同的键映射到同一索引，这种现象称为碰撞(collision)。处理碰撞的方法主要有两种：链式法，开发地址法
		2.1 链式法
			在每个数组位置存储一个链表(或其他数据结构如平衡树)。所有映射到同一索引的元素都存储在该链表中。
				优点：	实现简单，易于扩展
				缺点：	最坏的查询时间是O(n)
						需要额外的空间存储指针
		2.2 开放地址法
			所有元素存储在数组中，发生冲突时，按照一定探查序列寻找下一个可用位置。常见探查方法包括线性探查、二次探查、双重哈希
				优点：	无需额外地址空间，空间利用率高
						数据局部性好，适合缓存友好
				缺点：	实现较复杂，容易产生团聚现象，影响性能
						删除操作复杂
			常见探查方法：
				1. 线性探查：
						Index = (hash(key)+i)%TableSize, i=0,1,2
						按固定步长依次查找接下来的槽，直到找到空闲槽为止
						缺点：相邻槽形成聚集区，增加探查的次数
				2. 二次探查：
						Index = (hash(key)+c1*i+c2*i^2)%TableSize, i=0,1,2
						缺点：相比线性探查可以减少聚集
				3. 双重哈希
						Index = (hash1(key)+i*hash2(key))%TableSize, i=0,1,2
		2.3 布谷鸟哈希
			使用两个哈希表和两个哈希函数，每个键都有两个可能的位置。
			插入时，尝试插入位置1，如果位置1被占用，驱逐原有值并插入
				尝试将原有值插入位置2，如果位置2也被占用，驱逐位置2原有值，并递归插入
				若达到预定驱逐次数阈值，重新哈希整个表，通常使用新的哈希函数或增大表大小
		2.4 Hopscotch 哈希
			结合了链式法和开放地址法的优点。
			将每个元素尽可能存储在其"主桶"附近的一个固定距离范围内。这种限制操作使得查找操作可以在常数时间内完成。
			如果附近没有空闲桶，尝试通过移动现有元素的位置，在临近区外找到一个空闲桶。
		2.5 罗宾汉哈希
			开放地址法的改进。
			[探测深度]：对于某个键，探测深度是从初始哈希槽到实际存储槽的距离。
			罗宾汉哈希的思想是在插入过程中，较短探测序列的键可以被后插入且探测序列更长的键"抢劫"，即交换位置。
			插入操作中：
				1. 计算键的初始值，确定初始槽位置
				2. 若初始槽被占用，比较当前槽中键的探测深度与待插入键的探测深度
				3. 如果待插入键的探测深度大于当前槽中键的探测深度，交换两者位置，并将被替换的键作为新的待插入键。
		
	3. 负载因子和再哈希
		负载因子是哈希表中元素数量和桶数量的比值，通常表示为alpha = n/m. n是元素数量，m是桶数量。
			低负载因子空间利用率低，但查询速度快。
			高负载因子空间利用率高，但可能导致更多冲突，影响查询速度。
			
		再哈希
			当负载因子超过预定阈值时，哈希表会进行扩容。
			步骤：
				1. 选择新的桶数量：大约是原来两倍的质数。
				2. 分配新的数组
				3. 重新计算所有已有元素的哈希值，并插入新的数组中
	4. 字符串处理机制
		特点：
			复制存储：将字符串作为键插入哈希表，哈希表通常会存储字符串的一个副本。目的是确保内部键数据不会因外部修改而改变
			引用存储：某些优化实现中，哈希表可能存储指向字符串的引用或指针，特别是在字符串不需要修改且可以安全共享的情况下。
			常见哈希函数包括djb2, sdbm, MD5

18. vector和deque
	1. vector
	vector是c++标准模板库(STL)中的一个动态数组容器。
	std::vector采用连续内存块来存储元素，即所有元素在内存中紧密排列。这有以下优点：
		1. 快速随机访问
		2. 连续存储提高缓存命中率，提升性能
		3. 可以方便与C风格数组兼容
		
	成员变量：
		1.指向数组的指针 	T* data
		2.结束位置指针 		T* end或size
		3.容量指针			T* capacity或capacity
		
	管理内存；
		vector使用分配器(默认std::allocator)来管理内存。
		分配器主要负责：
			1. 分配和释放内存块
			2. 构造和销毁元素
			
	容量管理：
		容量(capacity)：是vector当前分配的内存块能容纳的最大元素数量
		大小(Size):		当前vector中实际存储的元素
		动态扩展： 当容量不足，vetor自动分配更大的内存块，并将现有元素移动到新内存中。通常自动分配大小为原来容量2倍。
		释放内存：	vector不会自动缩小容量，除非调用shrink_to_fit()
					当vector被销毁，分配器自动释放所有分配的内存，并调用元素的析构函数
	
	元素访问：
		采用随机访问迭代器，支持高效的跳转和偏移操作。
		插入与删除：尾部插入是高效的，通常为常数事件
					中间插入或删除涉及大量元素的移动，复杂度为线性时间。
		
	性能优化：
		可以使用reserve来预分配内存
		
	2. deque
	deque(双端队列)提供在两端高效插入和删除元素的能力。
	
	内部数据结构：
		采用[分段连续内存]的方式。
		deque将元素分割到多个固定大小的缓冲区，每个缓冲区存储一定数量的元素。
		这些缓冲区通过一个间接引用链接在一起，形成一个管理结构。
		
		缓冲区：每个缓冲区存储固定数量的元素，如512个。
		间接引用数组：是一个指针数组，指向各个缓冲区的起始地址。
		头尾指针：指向第一个缓冲区中第一个有效元素和最后一个缓冲区最后一个有效元素
		
	动态内存管理：
		当在头部或尾部插入元素，如果当前缓冲区空间不足，deque会分配新的缓冲区并添加到引用数组中。
	内存释放：
		若删除某元素导致缓冲区变空，deque会将其从引用数组中移除并释放内存
	
	元素访问：
		deque支持常数时间的随机访问：
			一级索引：通过map定位到具体缓冲区
			二级索引：缓冲区内部通过偏移量访问具体的元素
	插入和删除：
		在两端的插入和删除具有高效性，
		在中间位置的插入和删除涉及元素的移动，但由于分段结构比vector更优

19. allocator
	c++标准库提供的模板类，用于管理动态内存的分配、构造和销毁对象。
	默认情况下，STL容器如std::vector, std::list使用allocator作为默认的内存分配器
	
	成员函数：
		内存分配和释放：
			allocate(n):分配未初始化的内存
			deallocate(p,n)：释放先前分配的内存
		对象的构造和销毁
			construct(p, args...)
			destory(p):调用对象p的析构函数
	
		deallocate()仅回收内存，在调用deallocate前，必须确保所有对象都已销毁

20. void*
	void*被称作空指针或通用指针，是一种特殊指针类型，用于指向任意类型的数据。
	使用场景：
		1. 和C语言兼容
		2. 存储任意类型的数据
		3. 动态内存分配时，void*是malloc的返回值，需要将其转换为具体类型
		4. 实现回调函数，作为上下文参数，传递任意类型的数据

21. multiset
	关联容器，允许存储多个相同键值的元素
	基于平衡二叉搜索树实现(通常是红黑树)，确保所有元素按特定顺序(通常是升序)存储，同时支持高效的查找、插入和删除
	multiset提供lower_bound和upper_bound供范围查找
	
	时间复杂度
		基于平衡二叉搜索树，查找、插入和删除都是O(log n)
		
22. lock
	lock_guard和unique_lock
	lock_guard适用于简单的作用域锁定
	unique_lock更复杂一点，主要特点包括：
		支持手动锁定和解锁
		支持移动语义(所有权转移)
		常与条件变量一起使用
		
23. 回调
	回调指将一个函数作为参数传递给另一个函数，并在特定事件或操作完成后调用这个函数。回调函数分为同步回调和异步回调。
	
	
	回调机制：
	直接将类的成员函数传递给接受普通函数指针的接口会导致编译错误。
	问题根源：
		成员函数(非静态)的类型为：
			void (A::*)()表示这是A类的一个成员函数指针
			调用时需要一个对象实例，即通过对象或指针来调用：如a.callback()或(a_ptr->*callback)()
			编译器会隐式传递一个隐藏的this指针给成员函数，用于访问对象的成员变量和其他成员函数
			
		普通函数指针类型为：
			void (*)()
			调用时不需要任何对象实例。
	根本原因是使用this来传递成员函数，这个成员函数是代表某个对象的实例的。所以解决办法如：使用静态成员函数(不带实例)
	
	如何解决：
		1.使用静态成员函数和上下文指针
			1.1	声明一个静态的当前类对象指针: static A* instance, 
				在构造函数中传递this指针给instance
				在静态成员函数中调用instance->callback_f();而后将该静态成员函数作为参数传入接口
				不适用于多实例场景：这里类对象指针是静态的，只能初始化一次
			1.2 改进办法是使用上下文指针：修改function类型为 void(*function)(void*)
				在调用静态成员函数时将this传入void*接口并类型转换为A*作为instance，然后调用instance->callback_f();
		2.使用function和lambda表达式
	
	成员函数和成员函数指针：
		1.成员函数的调用
			通过对象或指针，如a.func()或a_ptr->func()
		2. 成员函数指针：
			将成员函数作为参数传递或存储，这就需要使用成员函数指针。
			成员函数指针的使用和声明。
			
24. auto
	用于在[局部变量]的声明中自动推导类型。
	不能用于[类的成员变量声明]
		理由是：编译器在类定义时需要确切知道每个成员变量的类型，以便正确分配内存和布局类结构
	
	解决方案包括：
		1. 使用std::function作为cmp类型
		2. 使用具体函数对象
		3. 声明cmp为静态成员函数
		4. 在成员函数内部使用auto
			
26. 宏&类型别名
	类型别名用于为现有类型创建一个新的名称
	可以使用typedef或using来定义类型别名
	
	宏是c/c++预处理器的功能，用于在编译前执行文本替换
	
	主要区别：
		1. 作用域
			类型别名受[作用域规则]的约束
			宏是全局的，在整个编译单元生效，除非被#undef
		2. 类型检查
			编译器对类型别名进行类型检查
		3. 命名空间
			类型别名可以在命名空间中定义，使其只在特定的命名空间中生效
		4. 模板
			类型别名支持模板和类型推断

27. 同步和异步区别
	同步：任务按照顺序依次执行，一个任务完成后才能进行下一个任务
	异步：任务可以并行执行，调用者在发起操作后无需等待其完成，可以立即执行后续代码，任务操作完成后通过回调函数、信号量等通知调用者。
	
	回调：
	
28. friend
	授予某个类或函数对另一个类的private和protected成员的访问权限
	
29. 引用
	为变量创建别名
	底层实现：
		在c++中使用引用时，编译器通常会将引用转换为指针，并在生成的汇编代码中使用该指针。
			这种转换过程对程序员来说是隐式的，不需要显式地管理。
		编译器优化：
			完全内联：	对于简单的引用，编译器可能会将引用完全内联，避免任何指针操作
			寄存器使用：如果引用生命周期很短，编译器可能将其值存储在寄存器中，而不是内存地址，从而提高效率
			消除冗余：	引用在函数中只使用一次，编译器可以直接将其替换为原始变量
	
	类型：
		可以分为左值引用和右值引用
			左值引用 T& 	绑定到左值，可以修改引用的对象
			右值引用 T&&	绑定到右值，通常用于实现移动语义和完美转发
	多重引用和引用折叠
		C++不支持引用的引用，多个引用会被折叠为一个引用
		
	引用和指针
		由于引用底层通常被实现为指针，引用和指针性能差别不大。
	引用的限制
		必须初始化：	在声明时必须初始化，无法延迟绑定
		不可重新绑定：	一但被绑定到某个对象，不能再绑定到其他对象
		不能为nullptr：	必须始终绑定到有效的对象，不能像指针一样指向nullptr
		
29.5 取地址符
		c++中，函数名在大多数情况下会隐式转换为指向该函数的指针。
		也就是说，在需要函数指针的时候，可以直接使用函数名，而不需要显式加上取地址符&
		
	何时必须用&
		1. 重载函数
			存在函数重载，编译器无法确定指的是哪个函数
		2. 处理类的非静态成员函数。
			
30. inline(内联)
	内联是一种将函数或变量的实际代码嵌入到调用点的优化方法。
		优点
			1. 消除函数调用的开销：避免执行跳转指令和堆栈操作
			2. 优化代码：允许编译器在内联后对代码进一步优化，如常量折叠
			3. 提高缓存性能：减少函数调用带来的指令跳转，有助于提高指令缓存的命中率
		缺点：
			1. 代码膨胀：增加可执行文件的大小
			2. 编译器需要处理更多的代码替换，可能增加编译时间
	inline作用：
		1. 建议编译器将函数内联,编译器根据自身优化策略决定是否内联
		2. 
	
	完全内联：
		编译器将函数或变量的所有访问点都进行内联处理，确保生成的机器代码中不再存在任何间接访问或函数调用的痕迹
	
	引用中的完全内联
		将引用转为对原始变量的直接操作，避免生成实际的指针操作
		
	c++17开始，可以使用inline在类内部进行静态成员变量初始化
		static inline A* instance = nullptr;
		
31. __标识符
	这些标识符主要由编译器和标准库实现,用户禁止定义。常见的有：
	1. 预定义宏
		__LINE__ 	当前代码行的行号		多用于日志记录和调试信息
		__FILE__ 	当前源文件的文件名	
		__cplusplus	当前使用的c++标准版本
		__func__	当前函数的名称，是标准化的
	
		__FUNCTION__最初作为扩展由编译器(如GCC)提供，不是C++标准的一部分，效果与__func__相同
		
	2. 编译器特定的关键字和扩展
		__builtin_expect	(GCC, Clang支持)用于提供优化信息，帮助编译器进行分支预测
							如if(__builtin_expect(EXP,N) 意思是EXP等于N的可能性很大
		__builtin_popcount	一个整数在二进制中1的位数
							注:c++20引入<bit>头文件提供std::popcount效果相同，这有助于跨平台开发
		__attribute__		基本语法：__attribute__((attribute_list))，跟在[函数声明]后
							常见的属性(attribute_list)包括：
								deprecated：标记函数、变量或类型过时，编译器在使用时会生成警告
								noreturn:	指示函数不会返回，用于优化和生成更好的警告信息
								always_inline, noinline：是否总是被内联或禁止内联
								packed：	不对结构体成员进行对齐
								aligned:	指定变量或类型的对齐方式

32. 数据对齐
	将数据的起始地址调整为某种特定的字节边界
		例如一个int类型通常4字节，意味着int类型变量的地址应该是4的倍数
	为什么需要？
		许多数据访问对齐的数据时效率更高
		一致的对齐方式有助于简化内存管理
	
	结构体中的对齐
		1. 成员变量的对齐
		需要满足成员变量的起始地址满足其自身的数据对齐要求
		2. 结构体整体对齐
			结构体整体大小需要是其内部成员最大对齐要求的倍数。
	
	基本数据类型(如char, int, double)也有自然对齐要求
	类也有对齐要求，因为c++类和结构体的唯一区别是默认的访问权限
	
	联合体：
		所有联合体共用一块内存，对齐要求是所有成员中最大对齐要求的那个。
		
33. STL
	unordered_map和map
	基本区别：
		1. 内部实现
			map用平衡二叉搜索树(通常红黑树), unordered_map用Hash表
			map键值按升序排列, unordered_map无特定顺序，取决于哈希函数
			时间复杂度：map的查找、插入、删除的平均和最坏时间复杂度全是O(logN),unordered_map平均O(1),最坏O(N)
			自定义排序：map可以自定义排序方式，unordered_map严格按照哈希函数存储
	
34. 红黑树
	一种(自平衡)二叉搜索树，由于左右子树高度差有可能大于1，所以不是严格意义上的平衡二叉树
		特征：
			1. 每个节点带有颜色属性：红色或黑色
			2. 根节点是黑色
			3. 叶子节点为黑色：这里说的叶子节点是底层的空节点(NULL)
			4. 一个节点为红色，子节点必须都是黑色
			5. 黑色平衡：从任一节点到其所有后代叶子节点的路径上，均包含相同数目的黑色节点
	为什么需要红黑树？
		AVL树(平衡二叉搜索树)的优点是查找、插入、删除的时间复杂度都是O(logN)
		但是插入或删除后高度差可能大于1导致平衡性破坏，为了维持平衡性需要对其旋转，而旋转的成本不小。
		如果插入数据随机，那么它就是接近平衡的二叉树。
			但是极端情况下插入数据有序，所有节点都在根节点的一侧，此时平衡树退化为链表，时间复杂度O(N)
			红黑树能解决这种非平衡问题。
		优点：对有序数据的查询操作不会慢到O(N)的时间复杂度
	红黑树的等价交换：
		将所有红色节点上移到和父节点同一高度，就是一棵四阶B树
		红黑树的黑色节点个数与4阶B树的节点总数相等
		在所有B树节点中，永远是黑色节点是父节点，红色节点是子节点。黑色节点在中间，红色节点在两边
	
	查找：
		作为二叉搜索树，与一般查找方式相同：
			从根节点开始，比较目标值与节点值，相同返回，目标值小于当前节点值转向右节点，大于转向左节点
	插入O(logN)：
		1. 按二叉搜索树的规则插入，并将其颜色设为红色
		2. 如果父节点是黑色，不需要额外操作
		3. 如果父节点是红色，需要恢复红黑树的性质(旋转和染色)
			分两种情况：
				3.1 如果叔叔节点为红色
					-将父节点和叔叔节点颜色改为黑色
					-将祖父节点颜色改为红色
					-将问题移到祖父节点上，递归进行调整
				3.2 叔叔节点为黑色
					如果插入节点在父节点的右子树，同时父节点在祖父节点的左子树(“<”),进行左旋
					如果插入节点在父节点的左子树，同时父节点在祖父节点的右子树(“>”),进行右旋
					调整父节点和祖父节点的颜色
	删除O(logN):
		1. 按二叉搜索树的规则找到要删除的节点
		2. 如果要删除的节点有两个子节点
			找到其中序后继(中序遍历的下一个节点)，将其值复制到当前节点，然后删除后继节点。 后继或前驱都行
		3. 删除的节点颜色处理：
			如果是红色节点直接删除
			如果是黑色节点：
				一系列调整，根据兄弟节点和邻居节点颜色确定。

	旋转：
		分为左旋和右旋
		左旋：将某个节点旋转为其右孩子的左孩子
		右旋：将某个节点旋转为其左孩子的右孩子
		
35. 递归优化
	递归如何优化
		1. 尾递归优化
			尾递归指的是递归调用发生在函数的末尾，即在返回递归调用的结果之前。
			尾递归优化的核心思想是将递归调用转为迭代，避免每次递归调用都创建新的栈帧。
				具体来说：编译器重用当前函数的栈帧来承载下一次递归调用的参数，而不额外分配新的栈空间。
		
		栈帧：也称为活动记录，是程序在执行函数调用时，在调用栈中分配的一块内存区域。
			每当一个函数被调用，系统为其分配一个新的栈帧，存储该函数执行所需的各种信息。
			函数执行完毕，对应的栈帧被销毁。
		一个典型的栈帧包括：
			返回地址：函数调用后程序需要返回的位置
			参数，局部变量
			保存的寄存器状态：在函数调用前，一些寄存器的值需要保存，以便函数返回后恢复到调用前的状态
			帧指针：指向当前栈帧的基地址，用于(通过偏移量)访问栈帧中的变量和参数
		2. 递归展开
			将递归调用的函数体直接嵌入到调用点，减少函数调用开销
				由于递归深度不确定和代码膨胀问题，实际编译器对递归展开支持有限
		3. 消除不必要的递归调用
			某些递归函数中存在多余的条件判断和无法到达的递归分支，可以通过编译器优化。
			例如：
				常量优化： 	如果递归函数的某些参数是常量，编译器预先计算结果，减少递归次数
				死代码消除：移除永远不会执行的递归分支
		4. 转换递归为迭代
			手动减少函数调用开销，提高执行效率

36. tuple
	c++11引入的模板类，类似pair，但不限元素个数
	大小在编译时已决定
	无法使用[]访问，必须使用std::get访问,

37. 内存分配
	1. 概述：内存通常被划分为以下几个区域：
		代码区：存储程序的机器指令
		数据区：
			静态数据区：存储全局变量和静态变量
			常量区：	存储字符串字面量和常量数据
			**字符串字面量是指在源代码中直接表示字符串数据的固定文本。是由一对双引号(")包围的字符序列。
				原始字符串字面量：std::string str = R"(内容)"，内容可以包含特殊字符或多行文本而无需转义序列
		堆区：用于动态内存分配
		栈区：用于存储局部变量、函数参数和返回地址
	
	2. 内存分配类型
		c++中内存分配主要分为静态分配和动态分配
		静态分配：
			静态分配的内存由编译器在编译时分配，生命周期贯穿程序的整个运行期间。
			包括全局变量、静态变量和常量。
		动态分配：
			动态分配的内存在运行时由程序员手动管理，主要通过堆进行分配和释放。
	
	3. 动态内存管理机制
		1. new和delete
			new：在堆上分配内存，并自动调用构造函数初始化对象
			delete:释放内存，并调用析构函数销毁对象
		2. malloc和free
			C风格的动态内存管理方法，定义在<cstdlib>中。
			malloc用于分配内存，返回void*指针
			free用于释放内存。
			需要手动进行类型转换和初始化
		3. new[]和delete[]
			动态分配和释放数组
	4. 其他概念
		1. 智能指针：	自动管理动态分配的内存
		2. 内存池：		预先分配一大块内存并在其中管理，减少频繁new/delete带来的开销
			适用于需要频繁分配和释放小块内存的场景。
	5. 使用现代c++特性
		智能指针用于管理内存；
		RAII容器如vector,string代替裸指针,自动管理资源
		移动语义通过移动构造函数和移动赋值运算符，减少不必要的内存拷贝，提高性能。

	malloc
		为该进程的[虚拟地址空间]分配一块连续的内存区域，并将其映射到物理内存或磁盘交换空间
			返回这块虚拟内存区域的指针，供程序调用
		物理内存的映射
			虽然malloc分配的是虚拟内存，但操作系统通过内存管理单元将虚拟地址映射到物理地址。这种映射是动态的，表现为：
			1. 按需分页：只有当程序实际访问某页虚拟内存时，操作系统才会将其映射到一个物理页框
			2. 页面置换：当物理内存不足时，操作系统可能将不活跃的页面移至磁盘交换空间，腾出物理内存给活跃的页面。
		
		malloc的底层实现
			1. malloc检查当前堆区域是否有足够的可用内存
			2.如果堆空间不足，使用brk/sbrk扩展堆
				方法是：调整进程的数据段，增加程序断点
				brk:设置数据段的末端，即程序断点的位置。
				sbrk:相对于当前程序断点，增加或减少数据段的大小。
			3. 当malloc请求的内存超过一定阈值(128kB),使用mmap来分配内存。
					这有助于减少堆的内存碎片，提高大块内存分配的效率。
				独立分配：通过mmap分配的内存块不会纳入堆的管理范围，而是独立存储，便于单独释放和管理。
		
		mmap的底层实现
			mmap是一个系统调用，用于将文件或设备映射到进程的虚拟地址空间，或分配匿名内存区域。
			当mmap被调用时，用户空间的内核会陷入内核模式，执行相应系统调用。
			void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
			参数验证->内存区域分配->页面表更新->返回映射地址	
			
			支持多种类型的内存映射
			a. 文件映射
				将文件内容直接映射到进程的虚拟地址空间，实现高效文件读写
			b. 匿名内存映射
				分配不与任何文件关联的内存区域，常用于线程栈、共享内存等
			c. 设备映射
				映射设备内存到用户空间，以便直接的设备访问。
				
			内存保护和权限
				通过prot参数控制映射区域的访问权限
			页面对齐
				要求映射地址和长度是页面大小的倍数
		
	类的定义与内存地址
		编译阶段：
			由编译器解析类的定义,包括成员变量，成员函数，继承关系等。
				这一阶段决定了类的内存布局：即每个成员变量在对象中的位置和大小
			使用类的类型信息进行类型检查、函数重载解析、模板实例化等
			类本身不占用运行时内存
				只有当创建类的实例时，才会在内存中分配具体的空间
		运行阶段：
			当程序运行并创建类的对象时(无论栈上、堆上还是全局/静态存储区),才会分配具体内存地址给这些对象的实例
			对象的内存地址在运行时动态分配的，取决于对象的创建方式和程序的内存分配策略

38. 二叉树
	度数：一个节点所拥有的直接子节点的数量
		在二叉树中，任何节点的度数都不会超过2

39. 如何让函数在main()函数之前被调用？
	1.使用全局对象的构造函数
		可以通过定义一个全局(静态)对象，在其构造函数中调用所需的函数。
		由于全局对象的构造函数在main()函数执行之前被调用，可以确保函数提前执行。
	2. 静态初始化块
		c++11引入的静态初始化机制
	
40. 排序
	快排：
		基于分治，基本思想是选择一个基准元素。
			将待排序序列分割成两部分，一部分所有元素都小于基准，另一部分都大于基准。
			递归对两部分进行排序
	堆排：
		将待排序序列构建成一个最大堆
	归并排序：
		也基于分治：将待排序序列不断对半分割，直到每个子序列只有一个元素。
			将相邻的子序列合并，使其成为有序序列。
			重复直到整个序列有序。
	
	时间复杂度：同时考虑平均、最好、最坏时间复杂度，
		这里只有快排的最坏时间复杂度是O(n^2), 其他全是O(nlog n)
		快排最坏时间复杂度的情况(递归深度达到n层)：
			1. 已经有序，每次选择最后一个元素为基准，切分出来的子部分左边有所有剩余元素，右边为空
			2. 所有元素相同
		如何避免：每次随机选择基准元素

	空间复杂度：
		快排是就地排序，但递归调用需要栈空间，平均空间复杂度为O(log n)
		堆排是严格的就地排序，空间复杂度 O(1)
		归并排序
			对于数组，需要额外的辅助数组，空间复杂度O(n)
			对于链表，可以就地，空间复杂度O(1)
		
	稳定性：
		只有归并排序是稳定的，即相等的元素在排序后可能会改变相对位置
		
	实际性能：
		快排的局部性好，常具有较好的缓存命中率
			优化方式：
				1. 选择三个元素中位数作为基准，减少最坏情况发生
				2. 尾递归优化
				3. 小数组切换：当子数组规模较小时，切换到插入排序				
		堆排的访问模式较为不连续，缓存命中率较低
			优化方式：
				1. 使用二叉堆的改进版本，如斐波那契堆
		归并天然适合并行处理，可在现代多核处理器上实现显著性能提升
			由于分割后左右部分排序相互不依赖，可以分配到不同的核心上同时进行排序
			外部排序：适合处理无法全部装入内存的大数据集，如磁盘上文件排序
			优化方式：
				1. 自底向上的迭代实现：减少递归开销
				2. 识别已排序的子序列，减少不必要的合并操作
	
	应用场景：
		1. 快排适用于内存充足且对性能要求高的场景：如内存中数据排序、数据库内部排序, std::sort()实现
		2. 堆排是原地排序，适用于内存资源有限的环境，或者需要保证最坏情况性能的场景
			常用于实现优先队列
		3. 归并适用于外部排序，如数据集无法完全加载到内存的场景。
			适用于链表结构，不需要随机访问，且可以在较低空间复杂度下实现。
			在多核或分布式系统中，能有效利用并行计算资源，提升处理效率。

40.5 主定理
	用于分析分治算法的时间复杂度	
		可以直接从递归关系中推导出算法的渐进时间复杂度

	
41. mutex
	shared_mutex
	c++标准库提供的一种同步原语，用于实现共享(读)和独占(写)访问控制。
	
	与其他锁的比较：
		1. std::mutex
			仅支持独占锁，不支持共享锁
		2. recursive_mutex
			允许同一线程多次获取锁，但不支持共享锁
			适用于递归调用的场景，但有死锁风险
	
42. 设计模式
	设计模式是软件工程中为解决特定问题而总结的可复用的解决方案。
		设计模式通常分三大类：
			1. 创建型模式：关注对象的创建过程，帮助在不同情况下创建对象
			2. 结构型模式：关注类和对象的组合，帮助构建更大的结构
			3. 行为型模式：关注对象之间的通信和职责分配，帮助管理对象间的交互
			
	-创建型模式：主要解决对象的创建问题，帮助系统在不同情况下灵活创建对象
		1. 单例模式
			确保一个类只有一个实例，并提供一个全局访问点
			应用场景：
				需要一个全局唯一的对象，如配置管理器、日志记录器等
		2. 工厂方法模式
			定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使得类的实例化延迟到子类
			应用场景：
				当一个类不知道它所需的对象的具体类型时。
				当一个类希望由子类来指定它所创建的对象时。
		3. 

43. sizeof和strlen
	strlen不带'\0'
	
	TODO：
	vector[i]=4的底层实现/push的底层实现
	迭代器实现归并排序
	华为1，3题
	输入M,n
	第一题：问最小的组合实现覆盖
	
	第三题：IP
		要求IP组尽可能多，相同IP组要IP包含的尽可能小，最后要小IP
		
			sort自定义排序，如果相同返回的是什么
	
	手搓socket
	
	http2, 3
	
	数组，实现归并
	
	
虾皮
	http和https区别
	对称和非对称加密
	为什么https用对称，非对称，区别？
	
	进程间通信方式
	有名管道和匿名管道区别
	文件映射
	文件映射的优势，为什么非用不可
	虚拟内存多大？
	调度算法
	分页的优势
	
	Hash函数
	频繁发生冲突怎么处理？
	扩容后发生了什么？数组全部搬移吗？那你原来除留余法不是没解决频繁冲突问题吗？
	
	虚函数
	虚函数表和虚表指针

    序列和反序列化：
	本项目采用protobuf。
	功能是将类似于结构体的消息序列化为二进制数据。
	方法：protobuf提供的SerializeToString
	
在分布式系统下，RPC调用是一个高并发场景：有很多客户端和服务端建立TCP连接，发送服务调用请求。
	
动态代理？
	RPC服务端对外提供可调用方法: LoginResonse UserServiceRpc::Login(LoginRequest)
		接收入参对象LoginRequest并返回对象 LoginResponse
	在.proto文件中注册，使用protoc编译该文件，得到一组.cc和.h文件。这组文件可以和c++程序对接，
		利用protobuf提供的方法来封装要传输的消息结构体
		
服务发现
	客户端获取服务对象方法提供者地址信息的过程，称为服务发现。
	服务发现机制提供两个功能：
		1. 服务注册：服务提供方在提供服务前把自己的服务对象注册到注册中心上，
			注册中心把这个服务提供者的地址信息和提供的服务对象名和方法名保存下来。
		2. 服务订阅：在服务调用方 启动时，去注册中心找自己需要的服务对象对应的服务提供者的地址信息
			缓存到本地，为远程调用做储备。
	本项目使用zookeeper实现服务发现功能。
	
Wathcher机制来更新注册中心

项目流程?
	在user.proto中注册->调用protoc生成user.cc和user.h
	其中提供的Service虚类 包括UserServiceRpc和UserServiceRpc_stub类
		继承至UserService类做业务层实现。
		
	main()
	先框架初始化
	
	#define EXIT_FAILURE 1
	exit() 函数用于终止程序的执行并向操作系统返回一个退出状态码。
	通常有两种退出状态码：
		EXIT_SUCCESS：表示程序成功执行并正常退出，通常值为 0
		EXIT_FAILURE：表示程序执行失败，通常值为 1 或其他非零值
	
	getopt的用法：
	int getopt(argc, argv, "i:")
	i为命令行选项，如'i', 'f'
		返回值：正确获取到返回当前处理的选项字符，如'i'
				如果没有更多可解析字符，返回-1
				
单例模式：
	一种设计模式，确保一个类只有一个实例

懒汉模式：
	单例模式的一种实现方式，特点是在需要实例时才会创建实例(即懒加载)
	
decltype 
	是 C++11 引入的一个关键字，用于查询表达式的类型
		
std::unique_ptr
	C++11 引入的智能指针，用于管理动态分配的内存或资源
	std::unique_ptr<T, Deleter> ptr;
	这里T类型是FILE*, 所以unique_ptr被销毁时调用fclose关闭文件就行，不需要delete。
	
	char buf[1024]
	while(fgets(buf, sizeof(buf),pf.get())!=nullptr){
		string read_buf
	}
	
substr()用法
	string substr (size_t pos = 0, size_t len = npos) const;
	
NotifyService()
	定义结构体ServiceInfo保存服务信息
			成员:	Service* service
					unordered_map method_map
	定义mp service_map保存
	从google::protobuf::Service()->GetDescriptor()中获取服务信息：method()和name()
		打印并存至method_map中。
	将服务名和ServiceInfo再存到service_map中
	
atexit()
	int atexit(void (*func)(void));
		C标准库中的一个函数，用于注册程序退出时需要调用的清理函数。
		注册的函数将在程序正常退出时被调用，
		无论是通过 exit() 退出，还是通过程序的 main() 函数结束时退出。
		
this指针
	this指针指向当前对象的实例，
	在非静态成员函数中可用
	
	
protobuf, service->GetDescriptor
	获取的是在service.proto中注册的服务和方法
	服务为UserServiceRpc, 方法为Login, Register, 原定义如下：
		service UserServiceRpc{
		rpc Login(LoginRequest) returns(LoginResponse);
		rpc Register(RegisterRequest) returns(RegisterResponse);
		}

构造拷贝函数(copy operator)
	Myclass (const Myclass &other){}
重载赋值函数(copy assignment operator)
	Myclass& operator=(const Myclass &other)
	
=delete特性
	用来明确禁止某个函数的调用
	
strerror_r
	int strerror_r(int errnum, char *buf, size_t n);
	参数：
		-errnum: 	错误代码
		-buf；		用户提供的存储错误描述的缓存
		-n:			缓存的大小

public和private
	public中的成员可以被任何函数、对象或类外代码访问
	private只能在类的内部(或通过友元函数)访问
	
	public常用于定义类的接口，而private用于隐藏类的内部实现细节，保证数据不被外部直接修改
	
. 和 -> 
	都用于访问对象的成员
	-有一个对象的实例（变量）时，可以使用点运算符 . 来访问其成员
	-当你有一个指向对象的指针时，需要使用箭头运算符 -> 来访问该对象的成员
	
	
指针和引用的区别
	指针存放某个对象的地址
	引用就是变量的别名
	
	1. 定义和声明：
		int x = 10;
		int *ptr = &x;
		int &ref = x;
	2. 使用和操作：
		指针：
			int value = *ptr; // 获取指针指向的值
			int address = &x; // 获取变量的地址
		引用：
			int newValue = ref; // 获取引用的值
	3. 空值和空引用
		指针可以为空表示不指向任何地址
		引用必须在声明时初始化，不能在后续改变引用绑定的对象
	4. 可变性
		可以改变指针指向的内存地址
		引用被初始化后一直引用同一个对象
		
数据类型
	short int long, long long
		short至少16位
		int至少和short一样长
		long至少32位，且至少和int 一样长
		long long至少64位，且至少和long 一样长
	
		8位bit=1字节
		
		unsigned：无符号，不存负数，存负数空间全拿来存正数
	
关键字

	
	static
		作用：控制变量和函数的生命周期、作用域及访问权限
		
		1.静态全局变量：
			在函数外部使用
			在程序的整个生命周期存在，不会因为离开作用域销毁
			只在声明它的源文件可见(即具有内部链接性)
		2.静态函数：
			在类内部使用
			属于类而不是类的实例，可以通过类名直接调用，而无需创建对象
			不能直接访问非静态成员变量或非静态成员函数
		3.静态成员变量
			在类内使用static修饰的成员变量
			所有类对象共享一个静态成员变量的副本
			必须在类外部单独定义，以为其分配存储空间
		4. 静态成员函数
			在类内使用static修饰的成员函数
			不能直接访问非静态成员变量或非静态成员函数
			可以通过类名直接调用，而无需创建对象
		5. 静态局部变量
			在函数内部使用的局部变量
			在程序的整个生命周期存在，但只在申明它的函数内可见

	define、typedef、inline
		define
			只是简单的字符串替换，没有类型检查
			在编译的预处理阶段起作用
			防止头文件重复引用
			不分配内存
		typedef
			用于创建类型的别名，提高代码的可读性和可维护性。
			有对应数据类型, 在编译时检查
			在编译、运行时起作用
		inline
			将内联函数编译完成后插入被调用的地方
			减少压栈、跳转和返回操作，减少函数调用开销
			是一类特殊函数，会进行类型检查
			编译器有可能拒绝inline请求
	
	const和define区别
		const定义常量，define定义宏
		const生效于编译阶段，define生效于预处理阶段
		const定义的常量存储在内存中，define不分配内存
		const定义常量有类型，define不带类型
		
	new 和 malloc
		new是c++运算符, malloc属于c标准库函数
		new分配内存并调用构造函数， malloc仅分配内存
		new 返回特定类型指针，malloc返回void*，需要显式类型转换
		new 分配失败时抛出std::bad_alloc异常, malloc返回NULL
		new 使用delete或delete[]释放内存，并自动调用析构函数, malloc使用free
		
			
const 和constexpr
	const用于声明一个变量为只读，即值在初始化后不能修改
	constexpr声明在编译时可以求值的常量表达式，在 需要编译时常量或优化 时使用
			
volatile
	与const绝对对立
	作用：确保本条指令不会因编译器优化而省略，保证对特殊地址的稳定访问


前置++和后置++的内部实现
	前置++直接修改并返回变量
	后置++创建一个临时拷贝，修改原变量后返回临时拷贝
	
atomic
	原子变量, 确保在多线程环境中线程安全执行
	Q: a++ int a=b；这两条语句是原子的吗？
	A: 不是，从编译器角度说，需要先将变量a对应的内存值搬运到某寄存器中，
		然后对该寄存器的值增1或改动，最后搬回内存。在这期间线程可能会改变
	

	为什么要用RPC
	RPC可以让我们像调用本地函数一样调用远程函数
		本地函数：在本地进程中执行并直接返回结果的
		远程函数：运行在其他主机或进程上的函数，需要通过网络请求调用函数并等待返回结果
	RPC是解决分布式系统通信问题的重要技术。在搭建分布式系统中，如果开发人员想要调用某个远程函数，
	编写这个函数逻辑时还需要编写网络通信的相关逻辑。RPC框架可以对 [调用远程函数，接收远程函数的处理]
	这个过程进行封装，让开发人员调用远程函数可以和调用本地函数一样，具有相同语义性。
	
分布式系统：就是说多个计算机或节点协同完成任务。

## 1. 函数定义
### 定义在头文件会怎么样？
- 优点：	
1. 易于代码复用，可以方便多个源文件(.cpp)包含并使用这些函数
2. 内联优化：将小型函数定义在头文件，编译器有更多机会进行内联优化
    所以内联函数(使用inline修饰)通常在头文件定义  
- 缺点：	
1. 多重定义：一个函数定义在头文件，而该头文件被多个源文件包含，在链接阶段会出现"重定义"错误  
因为每个包含该头文件的源文件都生成了一个函数实例，编译器无法确定哪个版本
- 解决办法：
    - 使用inline关键字：  
        告诉编译器允许在多个翻译单元中存在该函数的定义，从而避免重定义错误  
        同时,编译器可能会将该函数进行内联展开，提升执行效率

### 模板函数应该定义在哪里？
模板函数的实现通常定义在头文件。因为模板在编译时进行实例化，编译器需要在使用模板时看到完整定义，以便根据类型生成相应代码。