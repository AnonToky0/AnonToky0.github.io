---
title: "排序算法"
date: 2025-08-26 16:00:00 +0800
categories: [算法]
tags: [C++, 算法, 排序]
---

40. 排序
	快排：
		基于分治，基本思想是选择一个基准元素。
			将待排序序列分割成两部分，一部分所有元素都小于基准，另一部分都大于基准。
			递归对两部分进行排序
	堆排：
		将待排序序列构建成一个最大堆
	归并排序：
		也基于分治：将待排序序列不断对半分割，直到每个子序列只有一个元素。
			将相邻的子序列合并，使其成为有序序列。
			重复直到整个序列有序。
	
	时间复杂度：同时考虑平均、最好、最坏时间复杂度，
		这里只有快排的最坏时间复杂度是O(n^2), 其他全是O(nlog n)
		快排最坏时间复杂度的情况(递归深度达到n层)：
			1. 已经有序，每次选择最后一个元素为基准，切分出来的子部分左边有所有剩余元素，右边为空
			2. 所有元素相同
		如何避免：每次随机选择基准元素

	空间复杂度：
		快排是就地排序，但递归调用需要栈空间，平均空间复杂度为O(log n)
		堆排是严格的就地排序，空间复杂度 O(1)
		归并排序
			对于数组，需要额外的辅助数组，空间复杂度O(n)
			对于链表，可以就地，空间复杂度O(1)
		
	稳定性：
		只有归并排序是稳定的，即相等的元素在排序后可能会改变相对位置
		
	实际性能：
		快排的局部性好，常具有较好的缓存命中率
			优化方式：
				1. 选择三个元素中位数作为基准，减少最坏情况发生
				2. 尾递归优化
				3. 小数组切换：当子数组规模较小时，切换到插入排序				
		堆排的访问模式较为不连续，缓存命中率较低
			优化方式：
				1. 使用二叉堆的改进版本，如斐波那契堆
		归并天然适合并行处理，可在现代多核处理器上实现显著性能提升
			由于分割后左右部分排序相互不依赖，可以分配到不同的核心上同时进行排序
			外部排序：适合处理无法全部装入内存的大数据集，如磁盘上文件排序
			优化方式：
				1. 自底向上的迭代实现：减少递归开销
				2. 识别已排序的子序列，减少不必要的合并操作
	
	应用场景：
		1. 快排适用于内存充足且对性能要求高的场景：如内存中数据排序、数据库内部排序, std::sort()实现
		2. 堆排是原地排序，适用于内存资源有限的环境，或者需要保证最坏情况性能的场景
			常用于实现优先队列
		3. 归并适用于外部排序，如数据集无法完全加载到内存的场景。
			适用于链表结构，不需要随机访问，且可以在较低空间复杂度下实现。
			在多核或分布式系统中，能有效利用并行计算资源，提升处理效率。

## 归并排序
``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head||!head->next){
			return head;
		}
		ListNode* mid = findMid(head);
		ListNode *left = sortList(head);
		ListNode *right = sortList(mid);
		return merge(left,right);
    }

	ListNode* findMid(ListNode* head){
		// 找中点，同时拆分
		ListNode* slow = head, *fast = head;
		ListNode *prev = nullptr;
		while(fast && fast->next){
			prev = slow;
			slow = slow->next;
			fast = fast->next->next;
		}
		if(prev){
			prev->next = nullptr;
		}
		return slow;
	}

	ListNode* merge(ListNode* left, ListNode* right){
		ListNode dummy = ListNode(0);
		ListNode *tail = &dummy;
		while(left&&right){
			if(left->val<right->val){
				tail = left;
				left=left->next;
			}
			else{
				tail = right;
			}
			tail = tail ->next;
		}
		if(left){
			tail =left;
		}
		else{
			tail =right;
		}
		return dummy->next;
	}
};

```