---
title: "C++ 类和对象"
date: 2025-08-25 23:00:00 +0800
categories: [C++]
tags: [C++]
---

## 面向对象(Object Oriented Programming, OOP)
C++三大特性：封装、继承、多态
(也有说法是四大特性，第四个特性是抽象)

### 封装
将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。
### 继承
从已有类中派生出新类，新类具有已有类的属性(成员变量)和方法(成员函数)。  
并且扩展或修改这些属性和方法。

#### 继承列表：
``` C++
class 派生类 : [访问控制] 基类1, [访问控制] 基类2, ... {
    // 成员变量和成员函数
};
```
在冒号后的就是继承列表

##### 菱形继承问题：
一个类通过多个路径继承自同一个基类时，形成类似菱形的继承结构。  
可能导致基类被多次继承，从而引发二义性和资源冗余问题。
- 二义性
假设出现菱形继承, B::A, C::A, 而D::B,C  
当创建D对象并访问A成员时，编译器无法确定通过哪一个A类子对象来访问

###### 菱形继承解决方案：虚拟继承
基类在继承层次结构中只存在一份实例，从而避免冗余和二义性问题
- 原理：
1. 共享基类实例：所有通过虚拟继承从同一个基类继承的路径，共享一个基类的实例
2. 基类子对象唯一性：在最终派生类中，基类只出现一次。
- 语法：
在B、C继承时使用virtual关键字
``` C++
	class Derived : virtual public base {}
```
###### 虚拟继承对构造函数影响
使用虚拟继承情况下，构造最终派生类对象时，构造函数调用顺序如下：
1. 基类构造：
- 先 虚拟基类的构造函数：无论虚拟基类在继承列表中的位置如何，虚拟基类的构造函数总是最早被调用
- 后 非虚拟基类的构造函数  
如果有多个非虚拟基类，构造顺序取决于它们在继承列表中的声明顺序，而不是在类定义中的顺序

    ``` cpp
    class C : public B, public A {...}; // 继承列表顺序是 B, A
    ```

2. 派生类成员变量的构造
	按照在类中的声明先后顺序被构造
3. 派生类的构造函数

###### 虚拟继承对析构函数影响
与构造函数相反：
1. 派生类的析构函数
2. 非虚拟基类的析构函数
3. 虚拟基类的析构函数
	
- Q. 为什么先成员变量构造再构造函数？
在构造之前确保所有成员变量已正确初始化

- Q. 成员变量构造之后内存分配位置：
取决于对象本身的分配方式
- 当对象是局部变量，它及所有成员变量放在栈上
- 使用new创建的对象及其成员变量分配在堆上
- 全局或静态对象分配在数据段或静态存储区

### 多态
同一种操作作用于不同对象，可以有不同解释和实现。
- 静态多态：通过**函数重载**或****运算符重载**实现，编译时确定调用哪个函数
- 动态多态：又称函数重写，通过**虚函数**和**继承**实现，运行时根据对象的实际类型调用对应的函数。

#### 函数重载
C++中函数调用的解析是基于函数名和参数列表的**重载解析（Overload Resolution）**过程：
1. 收集候选函数集合（Candidate Functions）
2. 根据调用参数匹配最合适的函数
编译器根据调用时提供的参数类型，选择参数列表匹配最好的函数。
最佳匹配的规则包括：  
- 精确匹配优先
- 标准转换优先于用户定义的转换
- 转换序列短的优先
- 派生类成员函数优先于基类成员函数(通过 using 引入或继承)
3. 如果存在唯一最佳匹配，调用它；否则报重载二义性错误

#### 函数重写
-**为什么用基类指针调用虚函数？**
多态的核心就是：用统一接口操作不同类型的对象。
- 使用基类指针，代码只依赖基类接口，不依赖具体派生类，实现了面向接口编程。
- 这样未来添加新的派生类，不需要修改调用代码，只需继承并重写虚函数即可。
- 基类指针配合虚函数实现了动态绑定，即调用哪个函数在运行时决定，而不是编译时决定。

使用`virtual`，`virtual`是用于声明虚函数的关键字。  
- 虚函数允许在继承层级结构中实现动态绑定，即在运行时根据对象的实际类型调用相应的函数，而不是根据指针或引用的静态类型。
- 虚析构函数
	- 当使用基类指针删除子类对象时，如果基类的析构函数不是虚函数，可能导致资源泄漏。
	- 确保正确调用子类的析构函数
	- 资源泄漏的原因：如果基类的析构函数不是虚函数，会调用基类的析构函数。

- 虚函数表
	虚函数表是用来支持运行时多态的机制。当一个类声明了虚函数时，编译器为该类生成一个虚函数表。这个表包含指向该类所有虚函数的指针。
- 虚表指针
	每个对象中有一个指向虚函数表的指针，称为虚表指针

- 实现原理：
	- 虚表(vtable)是一个静态表格，存储了指向类的虚函数的指针。
    - 如果派生类重写了虚函数，编译器会为派生类生成一张新的虚函数表，覆盖对应虚函数指针。
	- 虚表指针(vptr)：每个对象包含一个隐藏的指针，指向该对象所属类的虚表。
		vptr通常在对象的内存布局中位于最前面。
- 工作机制：
	- 当对象被创建时，**构造函数**负责初始化vptr,让它指向所属类的虚表。
		- 对于继承关系，子类的构造函数会覆盖父类的vptr，指向子类的虚表。
	- 当通过基类指针或引用调用虚函数时，编译器生成代码，通过对象的vptr访问虚表，从虚表中找到相应的函数指针，并调用该函数
- 实现细节:
	- 虚表通常保存在只读数据段中，防止被意外修改。
	- 每个对象的内存布局中自动插入一个vptr，指向类的虚表。
	- 当子类重写虚函数时，子类的虚表会包含指向子类实现的函数指针，覆盖父类的相关条目。

- 单继承情况下，派生类的虚表覆盖（override）基类的虚函数表项，派生类虚表是独立的，指向派生类自己的虚函数实现。
- 多继承情况下，当一个类从多个基类继承（多继承）时，每个基类子对象部分有自己的虚表指针（vptr），因此，派生类对象中会有多个虚表指针，每个对应一个基类子对象。

- 为什么构造函数不能是虚函数？
构造函数是用于对象初始化的，而虚函数依赖于虚函数表，虚函数表的建立是在对象构造过程中设置的。

**注意**：如果派生类不是对基类的虚函数重写，而是对非虚函数隐藏，那么调用根据指针或对象静态类型对应的版本。关键点在于：
- 虚函数调用是动态绑定。
- 非虚函数调用是静态绑定。

详见以下例子：
``` cpp
class A
{
public:
    void draw() { std::cout << "A::draw\n"; } // 非虚函数
    void info()
    {
        std::cout << "A::info\n";
        draw(); // 调用 draw()
    }
};

class B : public A
{
public:
    void draw() { std::cout << "B::draw\n"; } // 非虚函数
    void info()
    {
        std::cout << "B::info\n";
        draw(); // 调用 draw()
    }
};

int main()
{
    B b;
    A *p = &b;

    std::cout << "\n调用 p->info():\n";
    p->info();

    return 0;
}
```

运行结果:  

``` 
调用 p->info():
A::info
A::draw
```

##### 底层实现：静态绑定与动态绑定
- 静态绑定
    - 函数调用在编译阶段就确定了调用哪个函数。
    - 函数调用依据的是 指针或引用的静态类型，而不是运行时对象的实际类型。
    - 编译器根据指针或引用的静态类型，直接生成调用对应函数的机器码。

- 动态绑定
    - 编译器为每个含虚函数的类生成一张虚函数表(vtable)，里面存放指向虚函数实现的指针。
    - 每个对象实例会有一个隐藏的指针指向对应类的虚函数表。
    - 调用虚函数时，程序通过对象的虚函数表指针找到正确的函数地址，进行调用。
    - 这样即使指针类型是基类，调用的仍是派生类的重写版本。

#### 构造顺序：
创建一个派生类对象时,构造函数的调用顺序遵循以下规则：
1. 虚拟基类的构造
2. 非虚拟基类的构造
3. 成员函数的构造
4. 派生类自身的构造
这种顺序确保虚拟基类在整个继承树中只被构造一次，并且在其他基类和成员对象之前完成，从而避免多次构造同一基类的问题

1. 虚拟基类的构造
	[虚拟继承]用于解决多重继承中的菱形继承问题，确保虚拟基类在继承层次结构中只存在一个实例。
2. 非虚拟基类的构造
3. 类的成员对象
4. 最后执行派生类的构造函数体

### 抽象
从具体实例中提取共同的特征，形成抽象类或接口，以便代码的复用和扩展。

#### 抽象类
**抽象类**是指至少包含一个纯虚函数的类。抽象类不能被实例化，只能作为其他类的基类，作为定义接口和共性行为。 
抽象类不能实例化，通常作为其他类的基类，提供接口和部分实现。
``` C++
class Abstract{
public:
    virtual void ab() = 0;
};
```
    
#### 纯虚函数
在基类中声明但不提供实现的函数，子类必须重写(实现)这些函数。
子类不重写的话必须也是抽象类。
``` C++
class Shape{
public:
    virtual double area() const = 0;
    
    virtual void describe() const{
    cout<<"output"<<endl;
    }
}
```

## 成员函数(Member Functions)
定义在类内部，用来操作类的对象（实例）的函数。
分为普通成员函数、虚成员函数、静态成员函数、特殊成员函数、常成员函数(const修饰)等。

| 成员函数类型 | 说明   | 是否算作普通成员函数 |
|--------------|-------------------|-------------------|
| 普通成员函数 | 无`virtual`，非静态成员函数           | 是   |
| 虚成员函数   | 使用`virtual`声明，支持多态           | 否   |
| 静态成员函数 | 使用`static`声明，不属于对象实例       | 否  |
| 特殊成员函数 | 构造函数、析构函数、赋值运算符等特殊函数 | 也可以是普通成员函数，但通常单独分类 |

## 特殊成员函数
- 默认构造函数
- 拷贝构造函数
- 移动构造函数
- 赋值运算符重载（拷贝赋值、移动赋值）
- 析构函数
这些函数可以是编译器自动生成的，也可以由程序员自定义。

- 在类内定义的成员函数默认是内联的，编译器会尝试优化成内联调用。
- 成员函数可以重载
- 成员函数可以是模板函数，支持泛型编程。

### 析构函数(Destructor)
析构函数是 C++ 类中的一种特殊成员函数，用于在对象生命周期结束时执行清理工作，比如释放资源、关闭文件、释放内存等。
- 析构函数不能带参数，也没有返回值。
- 当对象生命周期结束时，编译器会自动调用析构函数。
    - 对于局部对象，在其作用域结束时调用。
    - 对于动态分配的对象（用 new 创建），在调用 delete 时调用。
    - 对于全局或静态对象，在程序结束时调用。
- **只能有一个**析构函数，不能重载。

## 构造函数
### 拷贝构造函数
- 拷贝构造函数的职责是用一个已有对象来初始化一个新对象。
- 标准库和编译器默认生成的拷贝构造函数是**浅拷贝**，即逐成员复制（成员逐个按值复制），如果成员是指针，则只复制指针的地址，不复制指针指向的内容。
- 只有当类管理动态资源时，程序员才需要自定义拷贝构造函数来实现**深拷贝**，避免多个对象共享同一资源导致的问题。

``` cpp
class MyClass {
private:
    int* data;

public:
    // 构造函数
    MyClass(int value) {
        data = new int(value);
    }
	// 自定义拷贝构造函数（实现深拷贝）
    MyClass(const MyClass& other) {
        data = new int(*other.data);  // 申请新内存，复制值
    }
    // 析构函数
    ~MyClass() {
        delete data;
    }
};

int main() {
MyClass obj1(10);       // 调用构造函数
MyClass obj2 = obj1;  	// 调用拷贝构造函数，深拷贝

}
```

- **注意**
	- 拷贝构造函数只负责初始化对象内部成员，它不负责分配对象本身的内存。
	- 对象本身的内存由声明对象的方式决定：局部变量通常在栈上，动态分配的对象在堆上。
    ``` cpp
    MyClass obj1(10);       // obj1 在栈上，调用构造函数
    MyClass obj2 = obj1;    // obj2 在栈上，调用拷贝构造函数

    MyClass* pObj1 = new MyClass(30);         // pObj1 指向堆上对象，调用构造函数
    MyClass* pObj2 = new MyClass(*pObj1);     // pObj2 指向堆上对象，调用拷贝构造函数
    ```

### 三法则和五法则
“三法则”和“五法则”是C++中关于类的特殊成员函数的设计原则，主要用于管理类中资源（如动态内存、文件句柄等）的正确拷贝、赋值和销毁，避免资源泄漏、悬空指针等问题。

#### 三法则
如果一个类管理了动态资源（比如用裸指针new了内存），需要自定义以下三个特殊成员函数：
1. 拷贝构造函数 (Copy Constructor)
用于通过已有对象初始化新对象
2. 拷贝赋值运算符 (Copy Assignment Operator)
用于给已存在对象赋值，负责释放旧资源、深拷贝新资源。
3. 析构函数 (Destructor)
用于对象销毁时释放资源，防止内存泄漏。

#### 五法则
C++11引入了移动语义，新增了两个特殊成员函数：
4. 移动构造函数 (Move Constructor)
5. 移动赋值运算符 (Move Assignment Operator)  
当类管理资源时，如果自定义了三法则中的任意一个，建议同时自定义这两个移动操作，避免不必要的资源复制，提高效率。

### 空类
#### 空类定义
一个类没有非静态数据成员、没有虚函数、没有虚基类。**只看非静态数据成员和虚函数**来判断
- 成员函数（包括普通成员函数）不算数据成员，它们不占对象的存储空间。成员函数是类的代码部分，存储在程序的代码段(text segment)中
- 静态成员也不算对象的组成部分。
- 虚函数会导致类有虚函数表，创建对象有虚表指针，会增加对象大小，不算空类。

``` cpp
class Empty {
public:
    void foo() {}
};
```
这个类仍然是空类。

#### c++空类实现
C++为空类自动实现的函数包括：
- 默认构造函数
- 默认析构函数
- 拷贝构造函数
- 移动构造函数
- 拷贝赋值运算符：将一个已有对象的内容赋值给另一个对象
- 移动赋值运算符
		
空类的大小至少为**1字节**。这是由C++标准决定的，确保每个对象有唯一的地址。

#### 空基类优化 (Empty Base Optimization, EBO)
当空类作为其他类的基类时，编译器可能会应用空基类优化，从而使继承类的大小不因空基类而增加。
比如  
``` C++
class Empty {};

class parent: public Empty
	{
		int val;
	};
```
parent带有一个4字节的val，但parent类可能只占4字节。

- 如何实现的？
由编译器使用EBO, 在内存布局中，把空基类子对象的地址设置为派生类对象的起始地址（或与其他成员重叠）。  
由于空类没有数据成员，不会访问其成员数据，访问空基类部分不会产生冲突。以下为例子：  
``` cpp
#include <iostream>

class Empty {
public:
    void foo() {}
};

class Parent : public Empty {
public:
    int val;
};

int main() {
    Parent p;
    std::cout << "sizeof(Empty) = " << sizeof(Empty) << std::endl;
    std::cout << "sizeof(Parent) = " << sizeof(Parent) << std::endl;

    Empty* basePtr = &p;        // 空基类子对象的地址
    Parent* derivedPtr = &p;

    std::cout << "Parent对象地址: " << derivedPtr << std::endl;
    std::cout << "Empty子对象地址: " << basePtr << std::endl;

    return 0;
}
```

运行结果：

```
sizeof(Empty) = 1
sizeof(Parent) = 4
Parent对象地址: 0x5ffebc
Empty子对象地址: 0x5ffebc
```

- 内存示意：

| 地址偏移 | 内容         | 说明                          |
|----------|--------------|-------------------------------|
| 0x1000   | Empty子对象  | 空类，无成员，占用0字节（但地址存在） |
| 0x1000~0x1003 | int val  | `Parent`的成员变量，占4字节         |

- 结论：
    - 编译器在内存布局时，把空基类子对象的地址设置为派生类对象的起始地址（或与其他成员重叠）。
    - 由于空类没有数据成员，不会访问其成员数据，访问空基类部分不会产生冲突。
    - 这样，派生类对象的内存空间不会因空基类而增加。

## 函数隐藏(Name Hiding)
当派生类中定义了一个与基类中同名的成员函数（无论参数是否相同），派生类的函数会隐藏基类中所有同名函数，而不是重写它们。

- 隐藏发生在**非虚函数**或者函数签名不匹配的情况下。
- 隐藏是静态绑定，调用函数时根据指针或对象的静态类型决定调用哪个版本

### 具体表现
``` cpp
class Base {
public:
    void func() { std::cout << "Base::func()\n"; }
    void func(int) { std::cout << "Base::func(int)\n"; }
};

class Derived : public Base {
public:
    void func() { std::cout << "Derived::func()\n"; }
};
```
- Derived 定义了func()，会隐藏基类所有func函数，包括func(int)，即使参数列表不同。

``` cpp
int main() {
    Derived d;
    d.func();      // 调用 Derived::func()
    // d.func(10); // 编译错误，Base::func(int)被隐藏了
    d.Base::func(10); // 可以通过作用域限定符访问基类隐藏的函数
}
```
- `d.func(10)`会编译失败；
- 可以用`d.Base::func(10)`访问基类版本

### 设计目的
- 隐藏是**名字匹配**的，而不是**签名匹配**的。
- 隐藏的设计目的是防止派生类意外调用基类重载函数时产生歧义。
    - 比如上述例子, 调用`func(10)`, 由于派生类有`func()`，编译器会先在派生类查找func函数，但是派生类只定义了`func()`，没有`func(int)`。这会带来一些二义性和复杂的查找规则问题。

### 如何解决
使用`using` 声明引入基类函数  
``` cpp
class Derived : public Base {
public:
    using Base::func;  // 引入基类所有重载的 func 函数
    void func() { std::cout << "Derived::func()\n"; }
};
``` 

``` cpp
Derived d;
d.func();    // 调用 Derived::func()
d.func(10);  // 调用 Base::func(int)
```


