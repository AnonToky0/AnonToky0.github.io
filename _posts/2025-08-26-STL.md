---
title: "C++ STL"
date: 2025-08-26 15:00:00 +0800
categories: [C++]
tags: [STL, 模板, 容器]
---


## 容器(Container)
容器是 程序中用来存放和管理一组数据的结构。
在C++中，容器主要指的是标准模板库（STL）中的各种数据结构。

### 顺序容器
- std::vector：动态数组，支持快速随机访问
- std::list：双向链表，适合频繁插入删除
- std::deque：双端队列，可以从两端高效插入删除
- std::array：固定大小的数组

### 关联容器
- std::set：不重复的有序集合
- std::map：键值对映射，基于红黑树实现
- std::unordered_map：基于哈希表的键值对映射

### 容器适配器
std::stack、std::queue、std::priority_queue

## vector
vector是c++标准模板库(STL)中的一个动态数组容器。
std::vector采用连续内存块来存储元素，即所有元素在内存中紧密排列。这有以下优点：
1. 快速随机访问
2. 连续存储提高缓存命中率，提升性能
3. 可以方便与C风格数组兼容
    
- 成员变量：
1. 指向数组的指针 	T* data
2. 结束位置指针 	T* end或size
3. 容量指针			T* capacity或capacity

- 管理内存；
vector使用分配器(默认std::allocator)来管理内存。
分配器主要负责：  
1. 分配和释放内存块
2. 构造和销毁元素
    
- 容量管理：
    - 容量(capacity)：是vector当前分配的内存块能容纳的最大元素数量
    - 大小(Size):		当前vector中实际存储的元素
    - 动态扩展： 当容量不足，vetor自动分配更大的内存块，并将现有元素移动到新内存中。通常自动分配大小为原来容量2倍。
    - 释放内存：	vector不会自动缩小容量，除非调用shrink_to_fit()
                当vector被销毁，分配器自动释放所有分配的内存，并调用元素的析构函数

- 元素访问：
    - 采用随机访问迭代器，支持高效的跳转和偏移操作。  
    - 插入与删除：尾部插入是高效的，通常为常数事件。
    - 中间插入或删除涉及大量元素的移动，复杂度为线性时间。

- 性能优化：
可以使用reserve来预分配内存
    
## deque
deque(双端队列)提供在两端高效插入和删除元素的能力。

内部数据结构：
- 采用[分段连续内存]的方式。
- deque将元素分割到多个固定大小的缓冲区，每个缓冲区存储一定数量的元素。
- 这些缓冲区通过一个间接引用链接在一起，形成一个管理结构。

- 缓冲区：每个缓冲区存储固定数量的元素，如512个。
- 间接引用数组：是一个指针数组，指向各个缓冲区的起始地址。
- 头尾指针：指向第一个缓冲区中第一个有效元素和最后一个缓冲区最后一个有效元素
    
动态内存管理：  
当在头部或尾部插入元素，如果当前缓冲区空间不足，deque会分配新的缓冲区并添加到引用数组中。
内存释放：  
若删除某元素导致缓冲区变空，deque会将其从引用数组中移除并释放内存

元素访问：  
deque支持常数时间的随机访问： 
- 一级索引：通过map定位到具体缓冲区
- 二级索引：缓冲区内部通过偏移量访问具体的元素
插入和删除：  
- 在两端的插入和删除具有高效性，
- 在中间位置的插入和删除涉及元素的移动，但由于分段结构比vector更优

## allocator
c++标准库提供的模板类，用于管理动态内存的分配、构造和销毁对象。 
默认情况下，STL容器如std::vector, std::list使用allocator作为默认的内存分配器

### 成员函数
内存分配和释放：
- allocate(n):分配未初始化的内存
- deallocate(p,n)：释放先前分配的内存
对象的构造和销毁
- construct(p, args...)
- destory(p):调用对象p的析构函数

deallocate()仅回收内存，在调用deallocate前，必须确保所有对象都已销毁

## multiset
关联容器，允许存储多个相同键值的元素
基于平衡二叉搜索树实现(通常是红黑树)，确保所有元素按特定顺序(通常是升序)存储，同时支持高效的查找、插入和删除。
multiset提供lower_bound和upper_bound供范围查找

- 时间复杂度
基于平衡二叉搜索树，查找、插入和删除都是O(log n)

## unordered_map和map
基本区别：  
1. 内部实现
    - map用平衡二叉搜索树(通常红黑树), unordered_map用Hash表
    - map键值按升序排列, unordered_map无特定顺序，取决于哈希函数
    - 时间复杂度：map的查找、插入、删除的平均和最坏时间复杂度全是O(logN),unordered_map平均O(1),最坏O(N)
    - 自定义排序：map可以自定义排序方式，unordered_map严格按照哈希函数存储

## tuple
- C++11引入的模板类，类似pair，但不限元素个数
- 大小在编译时已决定
- 无法使用[]访问，必须使用std::get访问